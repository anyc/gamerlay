diff -Naur p47/import/opengl.d p47-gentoo/import/opengl.d
--- p47/import/opengl.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/opengl.d	2007-09-20 08:25:32.000000000 +0200
@@ -1,6 +1,4 @@
-import std.c.windows.windows;
-
-extern(Windows):
+	extern(C):
 
 alias uint GLenum;
 alias ubyte GLboolean;
@@ -1111,345 +1109,343 @@
 
 /*************************************************************/
 
-extern(Windows) void /*APIENTRY*/glAccum (GLenum op, GLfloat value);
-extern(Windows) void /*APIENTRY*/glAlphaFunc (GLenum func, GLclampf ref);
-extern(Windows) GLboolean /*APIENTRY*/glAreTexturesResident (GLsizei n, GLuint *textures, GLboolean *residences);
-extern(Windows) void /*APIENTRY*/glArrayElement (GLint i);
-extern(Windows) void /*APIENTRY*/glBegin (GLenum mode);
-extern(Windows) void /*APIENTRY*/glBindTexture (GLenum target, GLuint texture);
-extern(Windows) void /*APIENTRY*/glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, GLubyte *bitmap);
-extern(Windows) void /*APIENTRY*/glBlendFunc (GLenum sfactor, GLenum dfactor);
-extern(Windows) void /*APIENTRY*/glCallList (GLuint list);
-extern(Windows) void /*APIENTRY*/glCallLists (GLsizei n, GLenum type, GLvoid *lists);
-extern(Windows) void /*APIENTRY*/glClear (GLbitfield mask);
-extern(Windows) void /*APIENTRY*/glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
-extern(Windows) void /*APIENTRY*/glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
-extern(Windows) void /*APIENTRY*/glClearDepth (GLclampd depth);
-extern(Windows) void /*APIENTRY*/glClearIndex (GLfloat c);
-extern(Windows) void /*APIENTRY*/glClearStencil (GLint s);
-extern(Windows) void /*APIENTRY*/glClipPlane (GLenum plane, GLdouble *equation);
-extern(Windows) void /*APIENTRY*/glColor3b (GLbyte red, GLbyte green, GLbyte blue);
-extern(Windows) void /*APIENTRY*/glColor3bv (GLbyte *v);
-extern(Windows) void /*APIENTRY*/glColor3d (GLdouble red, GLdouble green, GLdouble blue);
-extern(Windows) void /*APIENTRY*/glColor3dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glColor3f (GLfloat red, GLfloat green, GLfloat blue);
-extern(Windows) void /*APIENTRY*/glColor3fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glColor3i (GLint red, GLint green, GLint blue);
-extern(Windows) void /*APIENTRY*/glColor3iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glColor3s (GLshort red, GLshort green, GLshort blue);
-extern(Windows) void /*APIENTRY*/glColor3sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
-extern(Windows) void /*APIENTRY*/glColor3ubv (GLubyte *v);
-extern(Windows) void /*APIENTRY*/glColor3ui (GLuint red, GLuint green, GLuint blue);
-extern(Windows) void /*APIENTRY*/glColor3uiv (GLuint *v);
-extern(Windows) void /*APIENTRY*/glColor3us (GLushort red, GLushort green, GLushort blue);
-extern(Windows) void /*APIENTRY*/glColor3usv (GLushort *v);
-extern(Windows) void /*APIENTRY*/glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
-extern(Windows) void /*APIENTRY*/glColor4bv (GLbyte *v);
-extern(Windows) void /*APIENTRY*/glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
-extern(Windows) void /*APIENTRY*/glColor4dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
-extern(Windows) void /*APIENTRY*/glColor4fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
-extern(Windows) void /*APIENTRY*/glColor4iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
-extern(Windows) void /*APIENTRY*/glColor4sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
-extern(Windows) void /*APIENTRY*/glColor4ubv (GLubyte *v);
-extern(Windows) void /*APIENTRY*/glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
-extern(Windows) void /*APIENTRY*/glColor4uiv (GLuint *v);
-extern(Windows) void /*APIENTRY*/glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
-extern(Windows) void /*APIENTRY*/glColor4usv (GLushort *v);
-extern(Windows) void /*APIENTRY*/glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
-extern(Windows) void /*APIENTRY*/glColorMaterial (GLenum face, GLenum mode);
-extern(Windows) void /*APIENTRY*/glColorPointer (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
-extern(Windows) void /*APIENTRY*/glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
-extern(Windows) void /*APIENTRY*/glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
-extern(Windows) void /*APIENTRY*/glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
-extern(Windows) void /*APIENTRY*/glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
-extern(Windows) void /*APIENTRY*/glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
-extern(Windows) void /*APIENTRY*/glCullFace (GLenum mode);
-extern(Windows) void /*APIENTRY*/glDeleteLists (GLuint list, GLsizei range);
-extern(Windows) void /*APIENTRY*/glDeleteTextures (GLsizei n, GLuint *textures);
-extern(Windows) void /*APIENTRY*/glDepthFunc (GLenum func);
-extern(Windows) void /*APIENTRY*/glDepthMask (GLboolean flag);
-extern(Windows) void /*APIENTRY*/glDepthRange (GLclampd zNear, GLclampd zFar);
-extern(Windows) void /*APIENTRY*/glDisable (GLenum cap);
-extern(Windows) void /*APIENTRY*/glDisableClientState (GLenum array);
-extern(Windows) void /*APIENTRY*/glDrawArrays (GLenum mode, GLint first, GLsizei count);
-extern(Windows) void /*APIENTRY*/glDrawBuffer (GLenum mode);
-extern(Windows) void /*APIENTRY*/glDrawElements (GLenum mode, GLsizei count, GLenum type, GLvoid *indices);
-extern(Windows) void /*APIENTRY*/glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
-extern(Windows) void /*APIENTRY*/glEdgeFlag (GLboolean flag);
-extern(Windows) void /*APIENTRY*/glEdgeFlagPointer (GLsizei stride, GLvoid *pointer);
-extern(Windows) void /*APIENTRY*/glEdgeFlagv (GLboolean *flag);
-extern(Windows) void /*APIENTRY*/glEnable (GLenum cap);
-extern(Windows) void /*APIENTRY*/glEnableClientState (GLenum array);
-extern(Windows) void /*APIENTRY*/glEnd ();
-extern(Windows) void /*APIENTRY*/glEndList ();
-extern(Windows) void /*APIENTRY*/glEvalCoord1d (GLdouble u);
-extern(Windows) void /*APIENTRY*/glEvalCoord1dv (GLdouble *u);
-extern(Windows) void /*APIENTRY*/glEvalCoord1f (GLfloat u);
-extern(Windows) void /*APIENTRY*/glEvalCoord1fv (GLfloat *u);
-extern(Windows) void /*APIENTRY*/glEvalCoord2d (GLdouble u, GLdouble v);
-extern(Windows) void /*APIENTRY*/glEvalCoord2dv (GLdouble *u);
-extern(Windows) void /*APIENTRY*/glEvalCoord2f (GLfloat u, GLfloat v);
-extern(Windows) void /*APIENTRY*/glEvalCoord2fv (GLfloat *u);
-extern(Windows) void /*APIENTRY*/glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
-extern(Windows) void /*APIENTRY*/glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
-extern(Windows) void /*APIENTRY*/glEvalPoint1 (GLint i);
-extern(Windows) void /*APIENTRY*/glEvalPoint2 (GLint i, GLint j);
-extern(Windows) void /*APIENTRY*/glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
-extern(Windows) void /*APIENTRY*/glFinish ();
-extern(Windows) void /*APIENTRY*/glFlush ();
-extern(Windows) void /*APIENTRY*/glFogf (GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glFogfv (GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glFogi (GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glFogiv (GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glFrontFace (GLenum mode);
-extern(Windows) void /*APIENTRY*/glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
-extern(Windows) GLuint /*APIENTRY*/glGenLists (GLsizei range);
-extern(Windows) void /*APIENTRY*/glGenTextures (GLsizei n, GLuint *textures);
-extern(Windows) void /*APIENTRY*/glGetBooleanv (GLenum pname, GLboolean *params);
-extern(Windows) void /*APIENTRY*/glGetClipPlane (GLenum plane, GLdouble *equation);
-extern(Windows) void /*APIENTRY*/glGetDoublev (GLenum pname, GLdouble *params);
-extern(Windows) GLenum /*APIENTRY*/glGetError ();
-extern(Windows) void /*APIENTRY*/glGetFloatv (GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glGetIntegerv (GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glGetLightiv (GLenum light, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glGetMapdv (GLenum target, GLenum query, GLdouble *v);
-extern(Windows) void /*APIENTRY*/glGetMapfv (GLenum target, GLenum query, GLfloat *v);
-extern(Windows) void /*APIENTRY*/glGetMapiv (GLenum target, GLenum query, GLint *v);
-extern(Windows) void /*APIENTRY*/glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glGetPixelMapfv (GLenum map, GLfloat *values);
-extern(Windows) void /*APIENTRY*/glGetPixelMapuiv (GLenum map, GLuint *values);
-extern(Windows) void /*APIENTRY*/glGetPixelMapusv (GLenum map, GLushort *values);
-extern(Windows) void /*APIENTRY*/glGetPointerv (GLenum pname, GLvoid* *params);
-extern(Windows) void /*APIENTRY*/glGetPolygonStipple (GLubyte *mask);
-extern(Windows) GLubyte * /*APIENTRY*/glGetString (GLenum name);
-extern(Windows) void /*APIENTRY*/glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
-extern(Windows) void /*APIENTRY*/glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
-extern(Windows) void /*APIENTRY*/glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glHint (GLenum target, GLenum mode);
-extern(Windows) void /*APIENTRY*/glIndexMask (GLuint mask);
-extern(Windows) void /*APIENTRY*/glIndexPointer (GLenum type, GLsizei stride, GLvoid *pointer);
-extern(Windows) void /*APIENTRY*/glIndexd (GLdouble c);
-extern(Windows) void /*APIENTRY*/glIndexdv (GLdouble *c);
-extern(Windows) void /*APIENTRY*/glIndexf (GLfloat c);
-extern(Windows) void /*APIENTRY*/glIndexfv (GLfloat *c);
-extern(Windows) void /*APIENTRY*/glIndexi (GLint c);
-extern(Windows) void /*APIENTRY*/glIndexiv (GLint *c);
-extern(Windows) void /*APIENTRY*/glIndexs (GLshort c);
-extern(Windows) void /*APIENTRY*/glIndexsv (GLshort *c);
-extern(Windows) void /*APIENTRY*/glIndexub (GLubyte c);
-extern(Windows) void /*APIENTRY*/glIndexubv (GLubyte *c);
-extern(Windows) void /*APIENTRY*/glInitNames ();
-extern(Windows) void /*APIENTRY*/glInterleavedArrays (GLenum format, GLsizei stride, GLvoid *pointer);
-extern(Windows) GLboolean /*APIENTRY*/glIsEnabled (GLenum cap);
-extern(Windows) GLboolean /*APIENTRY*/glIsList (GLuint list);
-extern(Windows) GLboolean /*APIENTRY*/glIsTexture (GLuint texture);
-extern(Windows) void /*APIENTRY*/glLightModelf (GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glLightModelfv (GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glLightModeli (GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glLightModeliv (GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glLightf (GLenum light, GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glLightfv (GLenum light, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glLighti (GLenum light, GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glLightiv (GLenum light, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glLineStipple (GLint factor, GLushort pattern);
-extern(Windows) void /*APIENTRY*/glLineWidth (GLfloat width);
-extern(Windows) void /*APIENTRY*/glListBase (GLuint base);
-extern(Windows) void /*APIENTRY*/glLoadIdentity ();
-extern(Windows) void /*APIENTRY*/glLoadMatrixd (GLdouble *m);
-extern(Windows) void /*APIENTRY*/glLoadMatrixf (GLfloat *m);
-extern(Windows) void /*APIENTRY*/glLoadName (GLuint name);
-extern(Windows) void /*APIENTRY*/glLogicOp (GLenum opcode);
-extern(Windows) void /*APIENTRY*/glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, GLdouble *points);
-extern(Windows) void /*APIENTRY*/glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, GLfloat *points);
-extern(Windows) void /*APIENTRY*/glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble *points);
-extern(Windows) void /*APIENTRY*/glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat *points);
-extern(Windows) void /*APIENTRY*/glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
-extern(Windows) void /*APIENTRY*/glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
-extern(Windows) void /*APIENTRY*/glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
-extern(Windows) void /*APIENTRY*/glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
-extern(Windows) void /*APIENTRY*/glMaterialf (GLenum face, GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glMaterialfv (GLenum face, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glMateriali (GLenum face, GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glMaterialiv (GLenum face, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glMatrixMode (GLenum mode);
-extern(Windows) void /*APIENTRY*/glMultMatrixd (GLdouble *m);
-extern(Windows) void /*APIENTRY*/glMultMatrixf (GLfloat *m);
-extern(Windows) void /*APIENTRY*/glNewList (GLuint list, GLenum mode);
-extern(Windows) void /*APIENTRY*/glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
-extern(Windows) void /*APIENTRY*/glNormal3bv (GLbyte *v);
-extern(Windows) void /*APIENTRY*/glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
-extern(Windows) void /*APIENTRY*/glNormal3dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
-extern(Windows) void /*APIENTRY*/glNormal3fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glNormal3i (GLint nx, GLint ny, GLint nz);
-extern(Windows) void /*APIENTRY*/glNormal3iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glNormal3s (GLshort nx, GLshort ny, GLshort nz);
-extern(Windows) void /*APIENTRY*/glNormal3sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glNormalPointer (GLenum type, GLsizei stride, GLvoid *pointer);
-extern(Windows) void /*APIENTRY*/glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
-extern(Windows) void /*APIENTRY*/glPassThrough (GLfloat token);
-extern(Windows) void /*APIENTRY*/glPixelMapfv (GLenum map, GLsizei mapsize, GLfloat *values);
-extern(Windows) void /*APIENTRY*/glPixelMapuiv (GLenum map, GLsizei mapsize, GLuint *values);
-extern(Windows) void /*APIENTRY*/glPixelMapusv (GLenum map, GLsizei mapsize, GLushort *values);
-extern(Windows) void /*APIENTRY*/glPixelStoref (GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glPixelStorei (GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glPixelTransferf (GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glPixelTransferi (GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glPixelZoom (GLfloat xfactor, GLfloat yfactor);
-extern(Windows) void /*APIENTRY*/glPointSize (GLfloat size);
-extern(Windows) void /*APIENTRY*/glPolygonMode (GLenum face, GLenum mode);
-extern(Windows) void /*APIENTRY*/glPolygonOffset (GLfloat factor, GLfloat units);
-extern(Windows) void /*APIENTRY*/glPolygonStipple (GLubyte *mask);
-extern(Windows) void /*APIENTRY*/glPopAttrib ();
-extern(Windows) void /*APIENTRY*/glPopClientAttrib ();
-extern(Windows) void /*APIENTRY*/glPopMatrix ();
-extern(Windows) void /*APIENTRY*/glPopName ();
-extern(Windows) void /*APIENTRY*/glPrioritizeTextures (GLsizei n, GLuint *textures, GLclampf *priorities);
-extern(Windows) void /*APIENTRY*/glPushAttrib (GLbitfield mask);
-extern(Windows) void /*APIENTRY*/glPushClientAttrib (GLbitfield mask);
-extern(Windows) void /*APIENTRY*/glPushMatrix ();
-extern(Windows) void /*APIENTRY*/glPushName (GLuint name);
-extern(Windows) void /*APIENTRY*/glRasterPos2d (GLdouble x, GLdouble y);
-extern(Windows) void /*APIENTRY*/glRasterPos2dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glRasterPos2f (GLfloat x, GLfloat y);
-extern(Windows) void /*APIENTRY*/glRasterPos2fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glRasterPos2i (GLint x, GLint y);
-extern(Windows) void /*APIENTRY*/glRasterPos2iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glRasterPos2s (GLshort x, GLshort y);
-extern(Windows) void /*APIENTRY*/glRasterPos2sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
-extern(Windows) void /*APIENTRY*/glRasterPos3dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
-extern(Windows) void /*APIENTRY*/glRasterPos3fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glRasterPos3i (GLint x, GLint y, GLint z);
-extern(Windows) void /*APIENTRY*/glRasterPos3iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glRasterPos3s (GLshort x, GLshort y, GLshort z);
-extern(Windows) void /*APIENTRY*/glRasterPos3sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
-extern(Windows) void /*APIENTRY*/glRasterPos4dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
-extern(Windows) void /*APIENTRY*/glRasterPos4fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
-extern(Windows) void /*APIENTRY*/glRasterPos4iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
-extern(Windows) void /*APIENTRY*/glRasterPos4sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glReadBuffer (GLenum mode);
-extern(Windows) void /*APIENTRY*/glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
-extern(Windows) void /*APIENTRY*/glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
-extern(Windows) void /*APIENTRY*/glRectdv (GLdouble *v1, GLdouble *v2);
-extern(Windows) void /*APIENTRY*/glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
-extern(Windows) void /*APIENTRY*/glRectfv (GLfloat *v1, GLfloat *v2);
-extern(Windows) void /*APIENTRY*/glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
-extern(Windows) void /*APIENTRY*/glRectiv (GLint *v1, GLint *v2);
-extern(Windows) void /*APIENTRY*/glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
-extern(Windows) void /*APIENTRY*/glRectsv (GLshort *v1, GLshort *v2);
-extern(Windows) GLint /*APIENTRY*/glRenderMode (GLenum mode);
-extern(Windows) void /*APIENTRY*/glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
-extern(Windows) void /*APIENTRY*/glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
-extern(Windows) void /*APIENTRY*/glScaled (GLdouble x, GLdouble y, GLdouble z);
-extern(Windows) void /*APIENTRY*/glScalef (GLfloat x, GLfloat y, GLfloat z);
-extern(Windows) void /*APIENTRY*/glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
-extern(Windows) void /*APIENTRY*/glSelectBuffer (GLsizei size, GLuint *buffer);
-extern(Windows) void /*APIENTRY*/glShadeModel (GLenum mode);
-extern(Windows) void /*APIENTRY*/glStencilFunc (GLenum func, GLint ref, GLuint mask);
-extern(Windows) void /*APIENTRY*/glStencilMask (GLuint mask);
-extern(Windows) void /*APIENTRY*/glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
-extern(Windows) void /*APIENTRY*/glTexCoord1d (GLdouble s);
-extern(Windows) void /*APIENTRY*/glTexCoord1dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glTexCoord1f (GLfloat s);
-extern(Windows) void /*APIENTRY*/glTexCoord1fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glTexCoord1i (GLint s);
-extern(Windows) void /*APIENTRY*/glTexCoord1iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glTexCoord1s (GLshort s);
-extern(Windows) void /*APIENTRY*/glTexCoord1sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glTexCoord2d (GLdouble s, GLdouble t);
-extern(Windows) void /*APIENTRY*/glTexCoord2dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glTexCoord2f (GLfloat s, GLfloat t);
-extern(Windows) void /*APIENTRY*/glTexCoord2fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glTexCoord2i (GLint s, GLint t);
-extern(Windows) void /*APIENTRY*/glTexCoord2iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glTexCoord2s (GLshort s, GLshort t);
-extern(Windows) void /*APIENTRY*/glTexCoord2sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
-extern(Windows) void /*APIENTRY*/glTexCoord3dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
-extern(Windows) void /*APIENTRY*/glTexCoord3fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glTexCoord3i (GLint s, GLint t, GLint r);
-extern(Windows) void /*APIENTRY*/glTexCoord3iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glTexCoord3s (GLshort s, GLshort t, GLshort r);
-extern(Windows) void /*APIENTRY*/glTexCoord3sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
-extern(Windows) void /*APIENTRY*/glTexCoord4dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
-extern(Windows) void /*APIENTRY*/glTexCoord4fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
-extern(Windows) void /*APIENTRY*/glTexCoord4iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
-extern(Windows) void /*APIENTRY*/glTexCoord4sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glTexCoordPointer (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
-extern(Windows) void /*APIENTRY*/glTexEnvf (GLenum target, GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glTexEnvi (GLenum target, GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glTexEnviv (GLenum target, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glTexGend (GLenum coord, GLenum pname, GLdouble param);
-extern(Windows) void /*APIENTRY*/glTexGendv (GLenum coord, GLenum pname, GLdouble *params);
-extern(Windows) void /*APIENTRY*/glTexGenf (GLenum coord, GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glTexGeni (GLenum coord, GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glTexGeniv (GLenum coord, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, GLvoid *pixels);
-extern(Windows) void /*APIENTRY*/glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLvoid *pixels);
-extern(Windows) void /*APIENTRY*/glTexParameterf (GLenum target, GLenum pname, GLfloat param);
-extern(Windows) void /*APIENTRY*/glTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
-extern(Windows) void /*APIENTRY*/glTexParameteri (GLenum target, GLenum pname, GLint param);
-extern(Windows) void /*APIENTRY*/glTexParameteriv (GLenum target, GLenum pname, GLint *params);
-extern(Windows) void /*APIENTRY*/glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, GLvoid *pixels);
-extern(Windows) void /*APIENTRY*/glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
-extern(Windows) void /*APIENTRY*/glTranslated (GLdouble x, GLdouble y, GLdouble z);
-extern(Windows) void /*APIENTRY*/glTranslatef (GLfloat x, GLfloat y, GLfloat z);
-extern(Windows) void /*APIENTRY*/glVertex2d (GLdouble x, GLdouble y);
-extern(Windows) void /*APIENTRY*/glVertex2dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glVertex2f (GLfloat x, GLfloat y);
-extern(Windows) void /*APIENTRY*/glVertex2fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glVertex2i (GLint x, GLint y);
-extern(Windows) void /*APIENTRY*/glVertex2iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glVertex2s (GLshort x, GLshort y);
-extern(Windows) void /*APIENTRY*/glVertex2sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glVertex3d (GLdouble x, GLdouble y, GLdouble z);
-extern(Windows) void /*APIENTRY*/glVertex3dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glVertex3f (GLfloat x, GLfloat y, GLfloat z);
-extern(Windows) void /*APIENTRY*/glVertex3fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glVertex3i (GLint x, GLint y, GLint z);
-extern(Windows) void /*APIENTRY*/glVertex3iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glVertex3s (GLshort x, GLshort y, GLshort z);
-extern(Windows) void /*APIENTRY*/glVertex3sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
-extern(Windows) void /*APIENTRY*/glVertex4dv (GLdouble *v);
-extern(Windows) void /*APIENTRY*/glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
-extern(Windows) void /*APIENTRY*/glVertex4fv (GLfloat *v);
-extern(Windows) void /*APIENTRY*/glVertex4i (GLint x, GLint y, GLint z, GLint w);
-extern(Windows) void /*APIENTRY*/glVertex4iv (GLint *v);
-extern(Windows) void /*APIENTRY*/glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
-extern(Windows) void /*APIENTRY*/glVertex4sv (GLshort *v);
-extern(Windows) void /*APIENTRY*/glVertexPointer (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
-extern(Windows) void /*APIENTRY*/glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
-
+void /*APIENTRY*/glAccum (GLenum op, GLfloat value);
+void /*APIENTRY*/glAlphaFunc (GLenum func, GLclampf);
+GLboolean /*APIENTRY*/glAreTexturesResident (GLsizei n, GLuint *textures, GLboolean *residences);
+void /*APIENTRY*/glArrayElement (GLint i);
+void /*APIENTRY*/glBegin (GLenum mode);
+void /*APIENTRY*/glBindTexture (GLenum target, GLuint texture);
+void /*APIENTRY*/glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, GLubyte *bitmap);
+void /*APIENTRY*/glBlendFunc (GLenum sfactor, GLenum dfactor);
+void /*APIENTRY*/glCallList (GLuint list);
+void /*APIENTRY*/glCallLists (GLsizei n, GLenum type, GLvoid *lists);
+void /*APIENTRY*/glClear (GLbitfield mask);
+void /*APIENTRY*/glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+void /*APIENTRY*/glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+void /*APIENTRY*/glClearDepth (GLclampd depth);
+void /*APIENTRY*/glClearIndex (GLfloat c);
+void /*APIENTRY*/glClearStencil (GLint s);
+void /*APIENTRY*/glClipPlane (GLenum plane, GLdouble *equation);
+void /*APIENTRY*/glColor3b (GLbyte red, GLbyte green, GLbyte blue);
+void /*APIENTRY*/glColor3bv (GLbyte *v);
+void /*APIENTRY*/glColor3d (GLdouble red, GLdouble green, GLdouble blue);
+void /*APIENTRY*/glColor3dv (GLdouble *v);
+void /*APIENTRY*/glColor3f (GLfloat red, GLfloat green, GLfloat blue);
+void /*APIENTRY*/glColor3fv (GLfloat *v);
+void /*APIENTRY*/glColor3i (GLint red, GLint green, GLint blue);
+void /*APIENTRY*/glColor3iv (GLint *v);
+void /*APIENTRY*/glColor3s (GLshort red, GLshort green, GLshort blue);
+void /*APIENTRY*/glColor3sv (GLshort *v);
+void /*APIENTRY*/glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
+void /*APIENTRY*/glColor3ubv (GLubyte *v);
+void /*APIENTRY*/glColor3ui (GLuint red, GLuint green, GLuint blue);
+void /*APIENTRY*/glColor3uiv (GLuint *v);
+void /*APIENTRY*/glColor3us (GLushort red, GLushort green, GLushort blue);
+void /*APIENTRY*/glColor3usv (GLushort *v);
+void /*APIENTRY*/glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
+void /*APIENTRY*/glColor4bv (GLbyte *v);
+void /*APIENTRY*/glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
+void /*APIENTRY*/glColor4dv (GLdouble *v);
+void /*APIENTRY*/glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+void /*APIENTRY*/glColor4fv (GLfloat *v);
+void /*APIENTRY*/glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
+void /*APIENTRY*/glColor4iv (GLint *v);
+void /*APIENTRY*/glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
+void /*APIENTRY*/glColor4sv (GLshort *v);
+void /*APIENTRY*/glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
+void /*APIENTRY*/glColor4ubv (GLubyte *v);
+void /*APIENTRY*/glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
+void /*APIENTRY*/glColor4uiv (GLuint *v);
+void /*APIENTRY*/glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
+void /*APIENTRY*/glColor4usv (GLushort *v);
+void /*APIENTRY*/glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+void /*APIENTRY*/glColorMaterial (GLenum face, GLenum mode);
+void /*APIENTRY*/glColorPointer (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
+void /*APIENTRY*/glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
+void /*APIENTRY*/glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
+void /*APIENTRY*/glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+void /*APIENTRY*/glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
+void /*APIENTRY*/glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+void /*APIENTRY*/glCullFace (GLenum mode);
+void /*APIENTRY*/glDeleteLists (GLuint list, GLsizei range);
+void /*APIENTRY*/glDeleteTextures (GLsizei n, GLuint *textures);
+void /*APIENTRY*/glDepthFunc (GLenum func);
+void /*APIENTRY*/glDepthMask (GLboolean flag);
+void /*APIENTRY*/glDepthRange (GLclampd zNear, GLclampd zFar);
+void /*APIENTRY*/glDisable (GLenum cap);
+void /*APIENTRY*/glDisableClientState (GLenum array);
+void /*APIENTRY*/glDrawArrays (GLenum mode, GLint first, GLsizei count);
+void /*APIENTRY*/glDrawBuffer (GLenum mode);
+void /*APIENTRY*/glDrawElements (GLenum mode, GLsizei count, GLenum type, GLvoid *indices);
+void /*APIENTRY*/glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+void /*APIENTRY*/glEdgeFlag (GLboolean flag);
+void /*APIENTRY*/glEdgeFlagPointer (GLsizei stride, GLvoid *pointer);
+void /*APIENTRY*/glEdgeFlagv (GLboolean *flag);
+void /*APIENTRY*/glEnable (GLenum cap);
+void /*APIENTRY*/glEnableClientState (GLenum array);
+void /*APIENTRY*/glEnd ();
+void /*APIENTRY*/glEndList ();
+void /*APIENTRY*/glEvalCoord1d (GLdouble u);
+void /*APIENTRY*/glEvalCoord1dv (GLdouble *u);
+void /*APIENTRY*/glEvalCoord1f (GLfloat u);
+void /*APIENTRY*/glEvalCoord1fv (GLfloat *u);
+void /*APIENTRY*/glEvalCoord2d (GLdouble u, GLdouble v);
+void /*APIENTRY*/glEvalCoord2dv (GLdouble *u);
+void /*APIENTRY*/glEvalCoord2f (GLfloat u, GLfloat v);
+void /*APIENTRY*/glEvalCoord2fv (GLfloat *u);
+void /*APIENTRY*/glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
+void /*APIENTRY*/glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
+void /*APIENTRY*/glEvalPoint1 (GLint i);
+void /*APIENTRY*/glEvalPoint2 (GLint i, GLint j);
+void /*APIENTRY*/glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
+void /*APIENTRY*/glFinish ();
+void /*APIENTRY*/glFlush ();
+void /*APIENTRY*/glFogf (GLenum pname, GLfloat param);
+void /*APIENTRY*/glFogfv (GLenum pname, GLfloat *params);
+void /*APIENTRY*/glFogi (GLenum pname, GLint param);
+void /*APIENTRY*/glFogiv (GLenum pname, GLint *params);
+void /*APIENTRY*/glFrontFace (GLenum mode);
+void /*APIENTRY*/glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
+GLuint /*APIENTRY*/glGenLists (GLsizei range);
+void /*APIENTRY*/glGenTextures (GLsizei n, GLuint *textures);
+void /*APIENTRY*/glGetBooleanv (GLenum pname, GLboolean *params);
+void /*APIENTRY*/glGetClipPlane (GLenum plane, GLdouble *equation);
+void /*APIENTRY*/glGetDoublev (GLenum pname, GLdouble *params);
+GLenum /*APIENTRY*/glGetError ();
+void /*APIENTRY*/glGetFloatv (GLenum pname, GLfloat *params);
+void /*APIENTRY*/glGetIntegerv (GLenum pname, GLint *params);
+void /*APIENTRY*/glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glGetLightiv (GLenum light, GLenum pname, GLint *params);
+void /*APIENTRY*/glGetMapdv (GLenum target, GLenum query, GLdouble *v);
+void /*APIENTRY*/glGetMapfv (GLenum target, GLenum query, GLfloat *v);
+void /*APIENTRY*/glGetMapiv (GLenum target, GLenum query, GLint *v);
+void /*APIENTRY*/glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
+void /*APIENTRY*/glGetPixelMapfv (GLenum map, GLfloat *values);
+void /*APIENTRY*/glGetPixelMapuiv (GLenum map, GLuint *values);
+void /*APIENTRY*/glGetPixelMapusv (GLenum map, GLushort *values);
+void /*APIENTRY*/glGetPointerv (GLenum pname, GLvoid* *params);
+void /*APIENTRY*/glGetPolygonStipple (GLubyte *mask);
+GLubyte * /*APIENTRY*/glGetString (GLenum name);
+void /*APIENTRY*/glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
+void /*APIENTRY*/glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
+void /*APIENTRY*/glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
+void /*APIENTRY*/glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
+void /*APIENTRY*/glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
+void /*APIENTRY*/glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
+void /*APIENTRY*/glHint (GLenum target, GLenum mode);
+void /*APIENTRY*/glIndexMask (GLuint mask);
+void /*APIENTRY*/glIndexPointer (GLenum type, GLsizei stride, GLvoid *pointer);
+void /*APIENTRY*/glIndexd (GLdouble c);
+void /*APIENTRY*/glIndexdv (GLdouble *c);
+void /*APIENTRY*/glIndexf (GLfloat c);
+void /*APIENTRY*/glIndexfv (GLfloat *c);
+void /*APIENTRY*/glIndexi (GLint c);
+void /*APIENTRY*/glIndexiv (GLint *c);
+void /*APIENTRY*/glIndexs (GLshort c);
+void /*APIENTRY*/glIndexsv (GLshort *c);
+void /*APIENTRY*/glIndexub (GLubyte c);
+void /*APIENTRY*/glIndexubv (GLubyte *c);
+void /*APIENTRY*/glInitNames ();
+void /*APIENTRY*/glInterleavedArrays (GLenum format, GLsizei stride, GLvoid *pointer);
+GLboolean /*APIENTRY*/glIsEnabled (GLenum cap);
+GLboolean /*APIENTRY*/glIsList (GLuint list);
+GLboolean /*APIENTRY*/glIsTexture (GLuint texture);
+void /*APIENTRY*/glLightModelf (GLenum pname, GLfloat param);
+void /*APIENTRY*/glLightModelfv (GLenum pname, GLfloat *params);
+void /*APIENTRY*/glLightModeli (GLenum pname, GLint param);
+void /*APIENTRY*/glLightModeliv (GLenum pname, GLint *params);
+void /*APIENTRY*/glLightf (GLenum light, GLenum pname, GLfloat param);
+void /*APIENTRY*/glLightfv (GLenum light, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glLighti (GLenum light, GLenum pname, GLint param);
+void /*APIENTRY*/glLightiv (GLenum light, GLenum pname, GLint *params);
+void /*APIENTRY*/glLineStipple (GLint factor, GLushort pattern);
+void /*APIENTRY*/glLineWidth (GLfloat width);
+void /*APIENTRY*/glListBase (GLuint base);
+void /*APIENTRY*/glLoadIdentity ();
+void /*APIENTRY*/glLoadMatrixd (GLdouble *m);
+void /*APIENTRY*/glLoadMatrixf (GLfloat *m);
+void /*APIENTRY*/glLoadName (GLuint name);
+void /*APIENTRY*/glLogicOp (GLenum opcode);
+void /*APIENTRY*/glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, GLdouble *points);
+void /*APIENTRY*/glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, GLfloat *points);
+void /*APIENTRY*/glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble *points);
+void /*APIENTRY*/glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat *points);
+void /*APIENTRY*/glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
+void /*APIENTRY*/glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
+void /*APIENTRY*/glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
+void /*APIENTRY*/glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
+void /*APIENTRY*/glMaterialf (GLenum face, GLenum pname, GLfloat param);
+void /*APIENTRY*/glMaterialfv (GLenum face, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glMateriali (GLenum face, GLenum pname, GLint param);
+void /*APIENTRY*/glMaterialiv (GLenum face, GLenum pname, GLint *params);
+void /*APIENTRY*/glMatrixMode (GLenum mode);
+void /*APIENTRY*/glMultMatrixd (GLdouble *m);
+void /*APIENTRY*/glMultMatrixf (GLfloat *m);
+void /*APIENTRY*/glNewList (GLuint list, GLenum mode);
+void /*APIENTRY*/glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
+void /*APIENTRY*/glNormal3bv (GLbyte *v);
+void /*APIENTRY*/glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
+void /*APIENTRY*/glNormal3dv (GLdouble *v);
+void /*APIENTRY*/glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
+void /*APIENTRY*/glNormal3fv (GLfloat *v);
+void /*APIENTRY*/glNormal3i (GLint nx, GLint ny, GLint nz);
+void /*APIENTRY*/glNormal3iv (GLint *v);
+void /*APIENTRY*/glNormal3s (GLshort nx, GLshort ny, GLshort nz);
+void /*APIENTRY*/glNormal3sv (GLshort *v);
+void /*APIENTRY*/glNormalPointer (GLenum type, GLsizei stride, GLvoid *pointer);
+void /*APIENTRY*/glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
+void /*APIENTRY*/glPassThrough (GLfloat token);
+void /*APIENTRY*/glPixelMapfv (GLenum map, GLsizei mapsize, GLfloat *values);
+void /*APIENTRY*/glPixelMapuiv (GLenum map, GLsizei mapsize, GLuint *values);
+void /*APIENTRY*/glPixelMapusv (GLenum map, GLsizei mapsize, GLushort *values);
+void /*APIENTRY*/glPixelStoref (GLenum pname, GLfloat param);
+void /*APIENTRY*/glPixelStorei (GLenum pname, GLint param);
+void /*APIENTRY*/glPixelTransferf (GLenum pname, GLfloat param);
+void /*APIENTRY*/glPixelTransferi (GLenum pname, GLint param);
+void /*APIENTRY*/glPixelZoom (GLfloat xfactor, GLfloat yfactor);
+void /*APIENTRY*/glPointSize (GLfloat size);
+void /*APIENTRY*/glPolygonMode (GLenum face, GLenum mode);
+void /*APIENTRY*/glPolygonOffset (GLfloat factor, GLfloat units);
+void /*APIENTRY*/glPolygonStipple (GLubyte *mask);
+void /*APIENTRY*/glPopAttrib ();
+void /*APIENTRY*/glPopClientAttrib ();
+void /*APIENTRY*/glPopMatrix ();
+void /*APIENTRY*/glPopName ();
+void /*APIENTRY*/glPrioritizeTextures (GLsizei n, GLuint *textures, GLclampf *priorities);
+void /*APIENTRY*/glPushAttrib (GLbitfield mask);
+void /*APIENTRY*/glPushClientAttrib (GLbitfield mask);
+void /*APIENTRY*/glPushMatrix ();
+void /*APIENTRY*/glPushName (GLuint name);
+void /*APIENTRY*/glRasterPos2d (GLdouble x, GLdouble y);
+void /*APIENTRY*/glRasterPos2dv (GLdouble *v);
+void /*APIENTRY*/glRasterPos2f (GLfloat x, GLfloat y);
+void /*APIENTRY*/glRasterPos2fv (GLfloat *v);
+void /*APIENTRY*/glRasterPos2i (GLint x, GLint y);
+void /*APIENTRY*/glRasterPos2iv (GLint *v);
+void /*APIENTRY*/glRasterPos2s (GLshort x, GLshort y);
+void /*APIENTRY*/glRasterPos2sv (GLshort *v);
+void /*APIENTRY*/glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
+void /*APIENTRY*/glRasterPos3dv (GLdouble *v);
+void /*APIENTRY*/glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
+void /*APIENTRY*/glRasterPos3fv (GLfloat *v);
+void /*APIENTRY*/glRasterPos3i (GLint x, GLint y, GLint z);
+void /*APIENTRY*/glRasterPos3iv (GLint *v);
+void /*APIENTRY*/glRasterPos3s (GLshort x, GLshort y, GLshort z);
+void /*APIENTRY*/glRasterPos3sv (GLshort *v);
+void /*APIENTRY*/glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+void /*APIENTRY*/glRasterPos4dv (GLdouble *v);
+void /*APIENTRY*/glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+void /*APIENTRY*/glRasterPos4fv (GLfloat *v);
+void /*APIENTRY*/glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
+void /*APIENTRY*/glRasterPos4iv (GLint *v);
+void /*APIENTRY*/glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
+void /*APIENTRY*/glRasterPos4sv (GLshort *v);
+void /*APIENTRY*/glReadBuffer (GLenum mode);
+void /*APIENTRY*/glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+void /*APIENTRY*/glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
+void /*APIENTRY*/glRectdv (GLdouble *v1, GLdouble *v2);
+void /*APIENTRY*/glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
+void /*APIENTRY*/glRectfv (GLfloat *v1, GLfloat *v2);
+void /*APIENTRY*/glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
+void /*APIENTRY*/glRectiv (GLint *v1, GLint *v2);
+void /*APIENTRY*/glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
+void /*APIENTRY*/glRectsv (GLshort *v1, GLshort *v2);
+GLint /*APIENTRY*/glRenderMode (GLenum mode);
+void /*APIENTRY*/glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
+void /*APIENTRY*/glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+void /*APIENTRY*/glScaled (GLdouble x, GLdouble y, GLdouble z);
+void /*APIENTRY*/glScalef (GLfloat x, GLfloat y, GLfloat z);
+void /*APIENTRY*/glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
+void /*APIENTRY*/glSelectBuffer (GLsizei size, GLuint *buffer);
+void /*APIENTRY*/glShadeModel (GLenum mode);
+void /*APIENTRY*/glStencilFunc (GLenum func, GLint, GLuint mask);
+void /*APIENTRY*/glStencilMask (GLuint mask);
+void /*APIENTRY*/glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
+void /*APIENTRY*/glTexCoord1d (GLdouble s);
+void /*APIENTRY*/glTexCoord1dv (GLdouble *v);
+void /*APIENTRY*/glTexCoord1f (GLfloat s);
+void /*APIENTRY*/glTexCoord1fv (GLfloat *v);
+void /*APIENTRY*/glTexCoord1i (GLint s);
+void /*APIENTRY*/glTexCoord1iv (GLint *v);
+void /*APIENTRY*/glTexCoord1s (GLshort s);
+void /*APIENTRY*/glTexCoord1sv (GLshort *v);
+void /*APIENTRY*/glTexCoord2d (GLdouble s, GLdouble t);
+void /*APIENTRY*/glTexCoord2dv (GLdouble *v);
+void /*APIENTRY*/glTexCoord2f (GLfloat s, GLfloat t);
+void /*APIENTRY*/glTexCoord2fv (GLfloat *v);
+void /*APIENTRY*/glTexCoord2i (GLint s, GLint t);
+void /*APIENTRY*/glTexCoord2iv (GLint *v);
+void /*APIENTRY*/glTexCoord2s (GLshort s, GLshort t);
+void /*APIENTRY*/glTexCoord2sv (GLshort *v);
+void /*APIENTRY*/glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
+void /*APIENTRY*/glTexCoord3dv (GLdouble *v);
+void /*APIENTRY*/glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
+void /*APIENTRY*/glTexCoord3fv (GLfloat *v);
+void /*APIENTRY*/glTexCoord3i (GLint s, GLint t, GLint r);
+void /*APIENTRY*/glTexCoord3iv (GLint *v);
+void /*APIENTRY*/glTexCoord3s (GLshort s, GLshort t, GLshort r);
+void /*APIENTRY*/glTexCoord3sv (GLshort *v);
+void /*APIENTRY*/glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+void /*APIENTRY*/glTexCoord4dv (GLdouble *v);
+void /*APIENTRY*/glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+void /*APIENTRY*/glTexCoord4fv (GLfloat *v);
+void /*APIENTRY*/glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
+void /*APIENTRY*/glTexCoord4iv (GLint *v);
+void /*APIENTRY*/glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
+void /*APIENTRY*/glTexCoord4sv (GLshort *v);
+void /*APIENTRY*/glTexCoordPointer (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
+void /*APIENTRY*/glTexEnvf (GLenum target, GLenum pname, GLfloat param);
+void /*APIENTRY*/glTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glTexEnvi (GLenum target, GLenum pname, GLint param);
+void /*APIENTRY*/glTexEnviv (GLenum target, GLenum pname, GLint *params);
+void /*APIENTRY*/glTexGend (GLenum coord, GLenum pname, GLdouble param);
+void /*APIENTRY*/glTexGendv (GLenum coord, GLenum pname, GLdouble *params);
+void /*APIENTRY*/glTexGenf (GLenum coord, GLenum pname, GLfloat param);
+void /*APIENTRY*/glTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glTexGeni (GLenum coord, GLenum pname, GLint param);
+void /*APIENTRY*/glTexGeniv (GLenum coord, GLenum pname, GLint *params);
+void /*APIENTRY*/glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, GLvoid *pixels);
+void /*APIENTRY*/glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLvoid *pixels);
+void /*APIENTRY*/glTexParameterf (GLenum target, GLenum pname, GLfloat param);
+void /*APIENTRY*/glTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
+void /*APIENTRY*/glTexParameteri (GLenum target, GLenum pname, GLint param);
+void /*APIENTRY*/glTexParameteriv (GLenum target, GLenum pname, GLint *params);
+void /*APIENTRY*/glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, GLvoid *pixels);
+void /*APIENTRY*/glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+void /*APIENTRY*/glTranslated (GLdouble x, GLdouble y, GLdouble z);
+void /*APIENTRY*/glTranslatef (GLfloat x, GLfloat y, GLfloat z);
+void /*APIENTRY*/glVertex2d (GLdouble x, GLdouble y);
+void /*APIENTRY*/glVertex2dv (GLdouble *v);
+void /*APIENTRY*/glVertex2f (GLfloat x, GLfloat y);
+void /*APIENTRY*/glVertex2fv (GLfloat *v);
+void /*APIENTRY*/glVertex2i (GLint x, GLint y);
+void /*APIENTRY*/glVertex2iv (GLint *v);
+void /*APIENTRY*/glVertex2s (GLshort x, GLshort y);
+void /*APIENTRY*/glVertex2sv (GLshort *v);
+void /*APIENTRY*/glVertex3d (GLdouble x, GLdouble y, GLdouble z);
+void /*APIENTRY*/glVertex3dv (GLdouble *v);
+void /*APIENTRY*/glVertex3f (GLfloat x, GLfloat y, GLfloat z);
+void /*APIENTRY*/glVertex3fv (GLfloat *v);
+void /*APIENTRY*/glVertex3i (GLint x, GLint y, GLint z);
+void /*APIENTRY*/glVertex3iv (GLint *v);
+void /*APIENTRY*/glVertex3s (GLshort x, GLshort y, GLshort z);
+void /*APIENTRY*/glVertex3sv (GLshort *v);
+void /*APIENTRY*/glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+void /*APIENTRY*/glVertex4dv (GLdouble *v);
+void /*APIENTRY*/glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+void /*APIENTRY*/glVertex4fv (GLfloat *v);
+void /*APIENTRY*/glVertex4i (GLint x, GLint y, GLint z, GLint w);
+void /*APIENTRY*/glVertex4iv (GLint *v);
+void /*APIENTRY*/glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
+void /*APIENTRY*/glVertex4sv (GLshort *v);
+void /*APIENTRY*/glVertexPointer (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
+void /*APIENTRY*/glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
 
-extern(Windows):
 
 /* EXT_vertex_array */
 typedef void (* PFNGLARRAYELEMENTEXTPROC) (GLint i);
@@ -1483,4 +1479,4 @@
 typedef void (* PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
     (GLenum target, GLenum pname, GLfloat *params);
 
-import openglu;
+//import openglu;
diff -Naur p47/import/openglu.d p47-gentoo/import/openglu.d
--- p47/import/openglu.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/openglu.d	2007-09-20 08:25:38.000000000 +0200
@@ -1,6 +1,6 @@
 import opengl;
 
-extern(Windows):
+	extern(C):
 
 GLubyte* gluErrorString (
     GLenum   errCode);
@@ -357,7 +357,6 @@
 
 /****           Tesselation constants           ****/
 
-//const extended GLU_TESS_MAX_COORD            = 1.0e150;
 const real GLU_TESS_MAX_COORD            = 1.0e150;
 
 /* TessProperty */
diff -Naur p47/import/SDL.d p47-gentoo/import/SDL.d
--- p47/import/SDL.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL.d	2007-09-20 08:24:15.000000000 +0200
@@ -31,7 +31,7 @@
 import SDL_events;
 import SDL_video;
 import SDL_byteorder;
-import SDL_version;
+import SDL_Version;
 
 extern(C):
 
@@ -73,6 +73,7 @@
  */
 void SDL_Quit();
 
+/+
 void SDL_SetModuleHandle(void *hInst);
 extern(Windows) void* GetModuleHandle(char*);
 
@@ -87,4 +88,5 @@
 static ~this()
 {
 	SDL_Quit();
-}
\ Kein Zeilenumbruch am Dateiende.
+}
++/
diff -Naur p47/import/SDL_endian.d p47-gentoo/import/SDL_endian.d
--- p47/import/SDL_endian.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_endian.d	2007-09-20 08:24:15.000000000 +0200
@@ -57,9 +57,9 @@
 Uint64 SDL_Swap64(Uint64 val) {
 	Uint32 hi, lo;
 	/* Separate into high and low 32-bit values and swap them */
-	lo = (Uint32)(val&0xFFFFFFFF);
+	lo = cast(Uint32)(val&0xFFFFFFFF);
 	val >>= 32;
-	hi = (Uint32)(val&0xFFFFFFFF);
+	hi = cast(Uint32)(val&0xFFFFFFFF);
 	val = SDL_Swap32(lo);
 	val <<= 32;
 	val |= SDL_Swap32(hi);
diff -Naur p47/import/SDL_events.d p47-gentoo/import/SDL_events.d
--- p47/import/SDL_events.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_events.d	2007-09-20 08:24:15.000000000 +0200
@@ -304,7 +304,7 @@
   If 'state' is set to SDL_QUERY, SDL_EventState() will return the 
   current processing state of the specified event.
 */
-const uint SDL_QUERY	= -1;
+const uint SDL_QUERY	= cast(uint) -1;
 const uint SDL_IGNORE	= 0;
 const uint SDL_DISABLE	= 0;
 const uint SDL_ENABLE	= 1;
diff -Naur p47/import/SDL_getenv.d p47-gentoo/import/SDL_getenv.d
--- p47/import/SDL_getenv.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_getenv.d	2007-09-20 08:24:15.000000000 +0200
@@ -2,6 +2,7 @@
 
 extern(C):
 
+/+
 /* Put a variable of the form "name=value" into the environment */
 int SDL_putenv(char *variable);
 int putenv(char* X) { return SDL_putenv(X); }
@@ -9,3 +10,4 @@
 /* Retrieve a variable named "name" from the environment */
 char *SDL_getenv(char *name);
 char *getenv(char* X) { return SDL_getenv(X); }
++/
diff -Naur p47/import/SDL_Keysym.d p47-gentoo/import/SDL_Keysym.d
--- p47/import/SDL_Keysym.d	1970-01-01 01:00:00.000000000 +0100
+++ p47-gentoo/import/SDL_Keysym.d	2007-09-20 08:24:15.000000000 +0200
@@ -0,0 +1,308 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997, 1998, 1999, 2000, 2001  Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@devolution.com
+*/
+
+/* What we really want is a mapping of every raw key on the keyboard.
+   To support international keyboards, we use the range 0xA1 - 0xFF
+   as international virtual keycodes.  We'll follow in the footsteps of X11...
+   The names of the keys
+ */
+ 
+alias int SDLKey;
+enum {
+	/* The keyboard syms have been cleverly chosen to map to ASCII */
+	SDLK_UNKNOWN		= 0,
+	SDLK_FIRST		= 0,
+	SDLK_BACKSPACE		= 8,
+	SDLK_TAB		= 9,
+	SDLK_CLEAR		= 12,
+	SDLK_RETURN		= 13,
+	SDLK_PAUSE		= 19,
+	SDLK_ESCAPE		= 27,
+	SDLK_SPACE		= 32,
+	SDLK_EXCLAIM		= 33,
+	SDLK_QUOTEDBL		= 34,
+	SDLK_HASH		= 35,
+	SDLK_DOLLAR		= 36,
+	SDLK_AMPERSAND		= 38,
+	SDLK_QUOTE		= 39,
+	SDLK_LEFTPAREN		= 40,
+	SDLK_RIGHTPAREN		= 41,
+	SDLK_ASTERISK		= 42,
+	SDLK_PLUS		= 43,
+	SDLK_COMMA		= 44,
+	SDLK_MINUS		= 45,
+	SDLK_PERIOD		= 46,
+	SDLK_SLASH		= 47,
+	SDLK_0			= 48,
+	SDLK_1			= 49,
+	SDLK_2			= 50,
+	SDLK_3			= 51,
+	SDLK_4			= 52,
+	SDLK_5			= 53,
+	SDLK_6			= 54,
+	SDLK_7			= 55,
+	SDLK_8			= 56,
+	SDLK_9			= 57,
+	SDLK_COLON		= 58,
+	SDLK_SEMICOLON		= 59,
+	SDLK_LESS		= 60,
+	SDLK_EQUALS		= 61,
+	SDLK_GREATER		= 62,
+	SDLK_QUESTION		= 63,
+	SDLK_AT			= 64,
+	/* 
+	   Skip uppercase letters
+	 */
+	SDLK_LEFTBRACKET	= 91,
+	SDLK_BACKSLASH		= 92,
+	SDLK_RIGHTBRACKET	= 93,
+	SDLK_CARET		= 94,
+	SDLK_UNDERSCORE		= 95,
+	SDLK_BACKQUOTE		= 96,
+	SDLK_a			= 97,
+	SDLK_b			= 98,
+	SDLK_c			= 99,
+	SDLK_d			= 100,
+	SDLK_e			= 101,
+	SDLK_f			= 102,
+	SDLK_g			= 103,
+	SDLK_h			= 104,
+	SDLK_i			= 105,
+	SDLK_j			= 106,
+	SDLK_k			= 107,
+	SDLK_l			= 108,
+	SDLK_m			= 109,
+	SDLK_n			= 110,
+	SDLK_o			= 111,
+	SDLK_p			= 112,
+	SDLK_q			= 113,
+	SDLK_r			= 114,
+	SDLK_s			= 115,
+	SDLK_t			= 116,
+	SDLK_u			= 117,
+	SDLK_v			= 118,
+	SDLK_w			= 119,
+	SDLK_x			= 120,
+	SDLK_y			= 121,
+	SDLK_z			= 122,
+	SDLK_DELETE		= 127,
+	/* End of ASCII mapped keysyms */
+
+	/* International keyboard syms */
+	SDLK_WORLD_0		= 160,		/* 0xA0 */
+	SDLK_WORLD_1		= 161,
+	SDLK_WORLD_2		= 162,
+	SDLK_WORLD_3		= 163,
+	SDLK_WORLD_4		= 164,
+	SDLK_WORLD_5		= 165,
+	SDLK_WORLD_6		= 166,
+	SDLK_WORLD_7		= 167,
+	SDLK_WORLD_8		= 168,
+	SDLK_WORLD_9		= 169,
+	SDLK_WORLD_10		= 170,
+	SDLK_WORLD_11		= 171,
+	SDLK_WORLD_12		= 172,
+	SDLK_WORLD_13		= 173,
+	SDLK_WORLD_14		= 174,
+	SDLK_WORLD_15		= 175,
+	SDLK_WORLD_16		= 176,
+	SDLK_WORLD_17		= 177,
+	SDLK_WORLD_18		= 178,
+	SDLK_WORLD_19		= 179,
+	SDLK_WORLD_20		= 180,
+	SDLK_WORLD_21		= 181,
+	SDLK_WORLD_22		= 182,
+	SDLK_WORLD_23		= 183,
+	SDLK_WORLD_24		= 184,
+	SDLK_WORLD_25		= 185,
+	SDLK_WORLD_26		= 186,
+	SDLK_WORLD_27		= 187,
+	SDLK_WORLD_28		= 188,
+	SDLK_WORLD_29		= 189,
+	SDLK_WORLD_30		= 190,
+	SDLK_WORLD_31		= 191,
+	SDLK_WORLD_32		= 192,
+	SDLK_WORLD_33		= 193,
+	SDLK_WORLD_34		= 194,
+	SDLK_WORLD_35		= 195,
+	SDLK_WORLD_36		= 196,
+	SDLK_WORLD_37		= 197,
+	SDLK_WORLD_38		= 198,
+	SDLK_WORLD_39		= 199,
+	SDLK_WORLD_40		= 200,
+	SDLK_WORLD_41		= 201,
+	SDLK_WORLD_42		= 202,
+	SDLK_WORLD_43		= 203,
+	SDLK_WORLD_44		= 204,
+	SDLK_WORLD_45		= 205,
+	SDLK_WORLD_46		= 206,
+	SDLK_WORLD_47		= 207,
+	SDLK_WORLD_48		= 208,
+	SDLK_WORLD_49		= 209,
+	SDLK_WORLD_50		= 210,
+	SDLK_WORLD_51		= 211,
+	SDLK_WORLD_52		= 212,
+	SDLK_WORLD_53		= 213,
+	SDLK_WORLD_54		= 214,
+	SDLK_WORLD_55		= 215,
+	SDLK_WORLD_56		= 216,
+	SDLK_WORLD_57		= 217,
+	SDLK_WORLD_58		= 218,
+	SDLK_WORLD_59		= 219,
+	SDLK_WORLD_60		= 220,
+	SDLK_WORLD_61		= 221,
+	SDLK_WORLD_62		= 222,
+	SDLK_WORLD_63		= 223,
+	SDLK_WORLD_64		= 224,
+	SDLK_WORLD_65		= 225,
+	SDLK_WORLD_66		= 226,
+	SDLK_WORLD_67		= 227,
+	SDLK_WORLD_68		= 228,
+	SDLK_WORLD_69		= 229,
+	SDLK_WORLD_70		= 230,
+	SDLK_WORLD_71		= 231,
+	SDLK_WORLD_72		= 232,
+	SDLK_WORLD_73		= 233,
+	SDLK_WORLD_74		= 234,
+	SDLK_WORLD_75		= 235,
+	SDLK_WORLD_76		= 236,
+	SDLK_WORLD_77		= 237,
+	SDLK_WORLD_78		= 238,
+	SDLK_WORLD_79		= 239,
+	SDLK_WORLD_80		= 240,
+	SDLK_WORLD_81		= 241,
+	SDLK_WORLD_82		= 242,
+	SDLK_WORLD_83		= 243,
+	SDLK_WORLD_84		= 244,
+	SDLK_WORLD_85		= 245,
+	SDLK_WORLD_86		= 246,
+	SDLK_WORLD_87		= 247,
+	SDLK_WORLD_88		= 248,
+	SDLK_WORLD_89		= 249,
+	SDLK_WORLD_90		= 250,
+	SDLK_WORLD_91		= 251,
+	SDLK_WORLD_92		= 252,
+	SDLK_WORLD_93		= 253,
+	SDLK_WORLD_94		= 254,
+	SDLK_WORLD_95		= 255,		/* 0xFF */
+
+	/* Numeric keypad */
+	SDLK_KP0		= 256,
+	SDLK_KP1		= 257,
+	SDLK_KP2		= 258,
+	SDLK_KP3		= 259,
+	SDLK_KP4		= 260,
+	SDLK_KP5		= 261,
+	SDLK_KP6		= 262,
+	SDLK_KP7		= 263,
+	SDLK_KP8		= 264,
+	SDLK_KP9		= 265,
+	SDLK_KP_PERIOD		= 266,
+	SDLK_KP_DIVIDE		= 267,
+	SDLK_KP_MULTIPLY	= 268,
+	SDLK_KP_MINUS		= 269,
+	SDLK_KP_PLUS		= 270,
+	SDLK_KP_ENTER		= 271,
+	SDLK_KP_EQUALS		= 272,
+
+	/* Arrows + Home/End pad */
+	SDLK_UP			= 273,
+	SDLK_DOWN		= 274,
+	SDLK_RIGHT		= 275,
+	SDLK_LEFT		= 276,
+	SDLK_INSERT		= 277,
+	SDLK_HOME		= 278,
+	SDLK_END		= 279,
+	SDLK_PAGEUP		= 280,
+	SDLK_PAGEDOWN		= 281,
+
+	/* Function keys */
+	SDLK_F1			= 282,
+	SDLK_F2			= 283,
+	SDLK_F3			= 284,
+	SDLK_F4			= 285,
+	SDLK_F5			= 286,
+	SDLK_F6			= 287,
+	SDLK_F7			= 288,
+	SDLK_F8			= 289,
+	SDLK_F9			= 290,
+	SDLK_F10		= 291,
+	SDLK_F11		= 292,
+	SDLK_F12		= 293,
+	SDLK_F13		= 294,
+	SDLK_F14		= 295,
+	SDLK_F15		= 296,
+
+	/* Key state modifier keys */
+	SDLK_NUMLOCK		= 300,
+	SDLK_CAPSLOCK		= 301,
+	SDLK_SCROLLOCK		= 302,
+	SDLK_RSHIFT		= 303,
+	SDLK_LSHIFT		= 304,
+	SDLK_RCTRL		= 305,
+	SDLK_LCTRL		= 306,
+	SDLK_RALT		= 307,
+	SDLK_LALT		= 308,
+	SDLK_RMETA		= 309,
+	SDLK_LMETA		= 310,
+	SDLK_LSUPER		= 311,		/* Left "Windows" key */
+	SDLK_RSUPER		= 312,		/* Right "Windows" key */
+	SDLK_MODE		= 313,		/* "Alt Gr" key */
+	SDLK_COMPOSE		= 314,		/* Multi-key compose key */
+
+	/* Miscellaneous function keys */
+	SDLK_HELP		= 315,
+	SDLK_PRINT		= 316,
+	SDLK_SYSREQ		= 317,
+	SDLK_BREAK		= 318,
+	SDLK_MENU		= 319,
+	SDLK_POWER		= 320,		/* Power Macintosh power key */
+	SDLK_EURO		= 321,		/* Some european keyboards */
+	SDLK_UNDO		= 322,		/* Atari keyboard has Undo */
+
+	/* Add any other keys here */
+
+	SDLK_LAST
+}
+
+/* Enumeration of valid key mods (possibly OR'd together) */
+alias int SDLMod;
+enum {
+	KMOD_NONE  = 0x0000,
+	KMOD_LSHIFT= 0x0001,
+	KMOD_RSHIFT= 0x0002,
+	KMOD_LCTRL = 0x0040,
+	KMOD_RCTRL = 0x0080,
+	KMOD_LALT  = 0x0100,
+	KMOD_RALT  = 0x0200,
+	KMOD_LMETA = 0x0400,
+	KMOD_RMETA = 0x0800,
+	KMOD_NUM   = 0x1000,
+	KMOD_CAPS  = 0x2000,
+	KMOD_MODE  = 0x4000,
+	KMOD_RESERVED = 0x8000
+}
+
+const uint KMOD_CTRL	= (KMOD_LCTRL|KMOD_RCTRL);
+const uint KMOD_SHIFT	= (KMOD_LSHIFT|KMOD_RSHIFT);
+const uint KMOD_ALT		= (KMOD_LALT|KMOD_RALT);
+const uint KMOD_META	= (KMOD_LMETA|KMOD_RMETA);
diff -Naur p47/import/SDL_mixer.d p47-gentoo/import/SDL_mixer.d
--- p47/import/SDL_mixer.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_mixer.d	2007-09-20 08:24:15.000000000 +0200
@@ -22,9 +22,32 @@
 
 // convert to D by shinichiro.h
 
-/* $Id: SDL_mixer.d,v 1.1.1.1 2003/11/28 17:26:28 kenta Exp $ */
+/* $Id: SDL_mixer.d,v 1.1.1.1 2005/06/18 00:46:00 kenta Exp $ */
 
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 
 extern (C) {
 
diff -Naur p47/import/SDL_mouse.d p47-gentoo/import/SDL_mouse.d
--- p47/import/SDL_mouse.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_mouse.d	2007-09-20 08:24:15.000000000 +0200
@@ -109,6 +109,8 @@
 const uint SDL_BUTTON_LEFT		= 1;
 const uint SDL_BUTTON_MIDDLE	= 2;
 const uint SDL_BUTTON_RIGHT		= 3;
+const uint SDL_BUTTON_WHEELUP	= 4;
+const uint SDL_BUTTON_WHEELDOWN	= 5;
 const uint SDL_BUTTON_LMASK		= SDL_PRESSED << (SDL_BUTTON_LEFT - 1);
 const uint SDL_BUTTON_MMASK		= SDL_PRESSED << (SDL_BUTTON_MIDDLE - 1);
 const uint SDL_BUTTON_RMASK		= SDL_PRESSED << (SDL_BUTTON_RIGHT - 1);
diff -Naur p47/import/SDL_quit.d p47-gentoo/import/SDL_quit.d
--- p47/import/SDL_quit.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_quit.d	2007-09-20 08:24:15.000000000 +0200
@@ -43,5 +43,5 @@
 bit SDL_QuitRequested()
 {
 	SDL_PumpEvents();
-	return SDL_PeepEvents(null, 0, SDL_PEEKEVENT, SDL_QUITMASK);
+	return cast(bit)SDL_PeepEvents(null, 0, SDL_PEEKEVENT, SDL_QUITMASK);
 }
diff -Naur p47/import/SDL_rwops.d p47-gentoo/import/SDL_rwops.d
--- p47/import/SDL_rwops.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_rwops.d	2007-09-20 08:24:15.000000000 +0200
@@ -28,6 +28,11 @@
 
 extern(C):
 
+typedef int (*_seek_func_t)(SDL_RWops *context, int offset, int whence);
+typedef int (*_read_func_t)(SDL_RWops *context, void *ptr, int size, int maxnum);
+typedef int (*_write_func_t)(SDL_RWops *context, void *ptr, int size, int num);
+typedef int (*_close_func_t)(SDL_RWops *context);
+
 /* This is the read/write operation structure -- very basic */
 
 struct SDL_RWops {
@@ -35,22 +40,26 @@
 		SEEK_SET, SEEK_CUR, SEEK_END
 	   Returns the final offset in the data source.
 	 */
-	int (*seek)(SDL_RWops *context, int offset, int whence);
+	_seek_func_t seek;
+//	int (*seek)(SDL_RWops *context, int offset, int whence);
 
 	/* Read up to 'num' objects each of size 'objsize' from the data
 	   source to the area pointed at by 'ptr'.
 	   Returns the number of objects read, or -1 if the read failed.
 	 */
-	int (*read)(SDL_RWops *context, void *ptr, int size, int maxnum);
+	_read_func_t read;
+//	int (*read)(SDL_RWops *context, void *ptr, int size, int maxnum);
 
 	/* Write exactly 'num' objects each of size 'objsize' from the area
 	   pointed at by 'ptr' to data source.
 	   Returns 'num', or -1 if the write failed.
 	 */
-	int (*write)(SDL_RWops *context, void *ptr, int size, int num);
+	_write_func_t write;
+//	int (*write)(SDL_RWops *context, void *ptr, int size, int num);
 
 	/* Close and free an allocated SDL_FSops structure */
-	int (*close)(SDL_RWops *context);
+	_close_func_t close;
+//	int (*close)(SDL_RWops *context);
 
 	Uint32 type;
 	union {
@@ -84,35 +93,40 @@
 /* Macros to easily read and write from an SDL_RWops structure */
 int SDL_RWseek(SDL_RWops *ctx, int offset, int whence)
 {
-	int (*seek)(SDL_RWops *context, int offset, int whence);
+	_seek_func_t seek;
+//	int (*seek)(SDL_RWops *context, int offset, int whence);
 	seek = ctx.seek;
 	return (*seek)(ctx, offset, whence);
 }
 
 int SDL_RWtell(SDL_RWops *ctx)
 {
-	int (*seek)(SDL_RWops *context, int offset, int whence);
+	_seek_func_t seek;
+//	int (*seek)(SDL_RWops *context, int offset, int whence);
 	seek = ctx.seek;
 	return (*seek)(ctx, 0, 1);
 }
 
 int SDL_RWread(SDL_RWops *ctx, void* ptr, int size, int n)
 {
-	int (*read)(SDL_RWops *context, void *ptr, int size, int maxnum);
+	_read_func_t read;
+//	int (*read)(SDL_RWops *context, void *ptr, int size, int maxnum);
 	read = ctx.read;
 	return (*read)(ctx, ptr, size, n);
 }
 
 int SDL_RWwrite(SDL_RWops *ctx, void* ptr, int size, int n)
 {
-	int (*write)(SDL_RWops *context, void *ptr, int size, int num);
+	_write_func_t write;
+//	int (*write)(SDL_RWops *context, void *ptr, int size, int num);
 	write = ctx.write;
 	return (*write)(ctx, ptr, size, n);
 }
 
 int SDL_RWclose(SDL_RWops *ctx)
 {
-	int (*close)(SDL_RWops *context);
+	_close_func_t close;
+//	int (*close)(SDL_RWops *context);
 	close = ctx.close;
 	return (*close)(ctx);
 }
diff -Naur p47/import/SDL_syswm.d p47-gentoo/import/SDL_syswm.d
--- p47/import/SDL_syswm.d	2003-11-29 02:26:28.000000000 +0100
+++ p47-gentoo/import/SDL_syswm.d	2007-09-20 08:24:15.000000000 +0200
@@ -22,7 +22,7 @@
 
 /* Include file for SDL custom system window manager hooks */
 
-import SDL_version;
+import SDL_Version;
 
 extern(C):
 
diff -Naur p47/import/SDL_Version.d p47-gentoo/import/SDL_Version.d
--- p47/import/SDL_Version.d	1970-01-01 01:00:00.000000000 +0100
+++ p47-gentoo/import/SDL_Version.d	2007-09-20 08:24:15.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997, 1998, 1999, 2000, 2001  Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@devolution.com
+*/
+
+/* This header defines the current SDL version */
+
+import SDL_types;
+
+extern(C):
+
+/* Printable format: "%d.%d.%d", MAJOR, MINOR, PATCHLEVEL
+*/
+const uint SDL_MAJOR_VERSION	= 1;
+const uint SDL_MINOR_VERSION	= 2;
+const uint SDL_PATCHLEVEL		= 6;
+
+struct SDL_version {
+	Uint8 major;
+	Uint8 minor;
+	Uint8 patch;
+}
+
+/* This macro can be used to fill a version structure with the compile-time
+ * version of the SDL library.
+ */
+void SDL_VERSION(SDL_version* X)
+{
+	X.major = SDL_MAJOR_VERSION;
+	X.minor = SDL_MINOR_VERSION;
+	X.patch = SDL_PATCHLEVEL;
+}
+
+/* This macro turns the version numbers into a numeric value:
+   (1,2,3) -> (1203)
+   This assumes that there will never be more than 100 patchlevels
+*/
+uint SDL_VERSIONNUM(Uint8 X, Uint8 Y, Uint8 Z)
+{
+	return X * 1000 + Y * 100 + Z;
+}
+
+/* This is the version number macro for the current SDL version */
+const uint SDL_COMPILEDVERSION = SDL_MAJOR_VERSION * 1000 +
+									SDL_MINOR_VERSION * 100 +
+									SDL_PATCHLEVEL;
+
+/* This macro will evaluate to true if compiled with SDL at least X.Y.Z */
+bit SDL_VERSION_ATLEAST(Uint8 X, Uint8 Y, Uint8 Z)
+{
+	return (SDL_COMPILEDVERSION >= SDL_VERSIONNUM(X, Y, Z));
+}
+
+/* This function gets the version of the dynamically linked SDL library.
+   it should NOT be used to fill a version structure, instead you should
+   use the SDL_Version() macro.
+ */
+SDL_version * SDL_Linked_Version();
diff -Naur p47/Makefile p47-gentoo/Makefile
--- p47/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ p47-gentoo/Makefile	2007-09-20 08:24:15.000000000 +0200
@@ -0,0 +1,29 @@
+DSRC=$(shell find src -name "*.d")
+SOURCES=$(DSRC) import/SDL_video.d import/SDL_mixer.d
+OBJS=$(SOURCES:.d=.o)
+CFLAGS=
+DFLAGS=-O -release -Iimport -Isrc -I/usr/X11R6/include/
+EXE=parsec47
+COBJS=src/dirent_d.o
+
+all: $(EXE)
+
+$(EXE): import/SDL_Keysym.d $(OBJS) $(COBJS)
+	gcc $(CFLAGS) -o $@ $(OBJS) $(COBJS) -lbulletml_d -L/usr/local/lib -L/usr/lib -lgphobos -lpthread -lGLU -lGL -lglut -lm -lstdc++ -lSDL -lSDL_mixer
+
+$(OBJS): %.o: %.d
+	gdmd -d -c -of$@ $(DFLAGS) $<
+
+src/dirent_d.o: src/dirent_d.c
+	gcc -c $< -o $@
+
+import/SDL_Keysym.d:
+	mv import/SDL_keysym.d import/SDL_Keysym.d
+
+
+clean:  rm src/*.o
+	rm src/abagames/p47/*.o
+	rm src/abagames/util/*.o
+	rm src/abagames/util/sdl/*.o
+	rm src/abagames/util/bulletml/*.o
+	rm import/*.o
diff -Naur p47/src/abagames/p47/Bonus.d p47-gentoo/src/abagames/p47/Bonus.d
--- p47/src/abagames/p47/Bonus.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/Bonus.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.Bonus;
 
-private:
+//private:
 import std.math;
 import opengl;
 import abagames.util.Vector;
@@ -63,7 +63,7 @@
   }
 
   public override void init(ActorInitializer ini) {
-    BonusInitializer bi = (BonusInitializer) ini;
+    BonusInitializer bi = cast(BonusInitializer) ini;
     field = bi.field;
     ship = bi.ship;
     manager = bi.manager;
@@ -126,13 +126,13 @@
 	missBonus();
 	isExist = false;
 	return;
-      }    
+      }
     }
     cnt++;
     if (cnt < RETRO_CNT)
       return;
     float d = pos.dist(ship.pos);
-    if (d < ACQUIRE_WIDTH * (1 + (float) inhaleCnt * 0.2) && ship.cnt >= -Ship.INVINCIBLE_CNT) {
+    if (d < ACQUIRE_WIDTH * (1 + cast(float) inhaleCnt * 0.2) && ship.cnt >= -Ship.INVINCIBLE_CNT) {
       getBonus();
       isExist = false;
       return;
@@ -157,8 +157,8 @@
   public override void draw() {
     float retro;
     if (cnt < RETRO_CNT)
-      retro = 1 - (float) cnt / RETRO_CNT;
-    else 
+      retro = 1 - cast(float) cnt / RETRO_CNT;
+    else
       retro = 0;
     float d = cnt * 0.1;
     float ox = sin(d) * 0.3;
@@ -176,9 +176,9 @@
 	Screen3D.setColor(0.4, 0.9, 0.6, 0.7);
       else
 	Screen3D.setColor(0.8, 0.9, 0.5, 0.7);
-      P47Screen.drawBoxLine(pos.x - ox - BOX_SIZE / 2, pos.y - oy - BOX_SIZE / 2, 
+      P47Screen.drawBoxLine(pos.x - ox - BOX_SIZE / 2, pos.y - oy - BOX_SIZE / 2,
 			    BOX_SIZE, BOX_SIZE);
-      P47Screen.drawBoxLine(pos.x + ox - BOX_SIZE / 2, pos.y + oy - BOX_SIZE / 2, 
+      P47Screen.drawBoxLine(pos.x + ox - BOX_SIZE / 2, pos.y + oy - BOX_SIZE / 2,
 			    BOX_SIZE, BOX_SIZE);
       P47Screen.drawBoxLine(pos.x - oy - BOX_SIZE / 2, pos.y + ox - BOX_SIZE / 2,
 			    BOX_SIZE, BOX_SIZE);
diff -Naur p47/src/abagames/p47/BulletActor.d p47-gentoo/src/abagames/p47/BulletActor.d
--- p47/src/abagames/p47/BulletActor.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/BulletActor.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.BulletActor;
 
-private:
+//private:
 import std.math;
 import opengl;
 import bulletml;
@@ -59,7 +59,7 @@
   }
 
   public override void init(ActorInitializer ini) {
-    BulletActorInitializer bi = (BulletActorInitializer) ini;
+    BulletActorInitializer bi = cast(BulletActorInitializer) ini;
     field = bi.field;
     ship = bi.ship;
     bullet = new P47Bullet(nextId);
@@ -80,8 +80,8 @@
     backToRetro = false;
   }
 
-  public void set(BulletMLRunner* runner, 
-		  float x, float y, float deg, float speed, float rank, 
+  public void set(BulletMLRunner* runner,
+		  float x, float y, float deg, float speed, float rank,
 		  float speedRank, int shape, int color, float size, float xReverse) {
     bullet.set(runner, x, y, deg, speed, rank);
     bullet.isMorph = false;
@@ -89,8 +89,8 @@
     start(speedRank, shape, color, size, xReverse);
   }
 
-  public void set(BulletMLRunner* runner, 
-		  float x, float y, float deg, float speed, float rank, 
+  public void set(BulletMLRunner* runner,
+		  float x, float y, float deg, float speed, float rank,
 		  float speedRank, int shape, int color, float size, float xReverse,
 		  BulletMLParser *morph[], int morphNum, int morphIdx, int morphCnt) {
     bullet.set(runner, x, y, deg, speed, rank);
@@ -163,8 +163,8 @@
 	if (hd >= 0 && hd <= SHIP_HIT_WIDTH) {
 	  ship.destroyed();
 	}
-      } 
-    }   
+      }
+    }
   }
 
   public override void move() {
@@ -200,9 +200,9 @@
       if (cnt > BULLET_DISAPPEAR_CNT)
 	toRetro();
     }
-    bullet.pos.x += 
+    bullet.pos.x +=
       (sin(bullet.deg) * bullet.speed + bullet.acc.x) * sr * bullet.xReverse;
-    bullet.pos.y += 
+    bullet.pos.y +=
       (cos(bullet.deg) * bullet.speed - bullet.acc.y) * sr;
     if (isVisible) {
       totalBulletsSpeed += bullet.speed * sr;
@@ -231,8 +231,8 @@
   private void drawRetro(float d) {
     float rt = 1 - rtCnt / RETRO_CNT;
     P47Screen.setRetroParam(rt, 0.4 * bullet.bulletSize);
-    P47Screen.setRetroColor(bulletColor[bullet.color][0], 
-			    bulletColor[bullet.color][1], 
+    P47Screen.setRetroColor(bulletColor[bullet.color][0],
+			    bulletColor[bullet.color][1],
 			    bulletColor[bullet.color][2], 1);
     float x, y, tx, px, py, fx, fy;
     for (int i = 0; i < shapePos[bullet.shape].length; i++) {
@@ -291,9 +291,9 @@
   private static const float SHAPE_BASE_COLOR_R = 1;
   private static const float SHAPE_BASE_COLOR_G = 0.9;
   private static const float SHAPE_BASE_COLOR_B = 0.7;
-  private static const float bulletColor[BULLET_COLOR_NUM][3] = 
+  private static const float bulletColor[BULLET_COLOR_NUM][3] =
     [
-     [1, 0, 0], [0.2, 1, 0.4], [0.3, 0.3, 1], [1, 1, 0], 
+     [1, 0, 0], [0.2, 1, 0.4], [0.3, 0.3, 1], [1, 1, 0],
      ];
 
   public static void createDisplayLists() {
diff -Naur p47/src/abagames/p47/BulletActorPool.d p47-gentoo/src/abagames/p47/BulletActorPool.d
--- p47/src/abagames/p47/BulletActorPool.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/BulletActorPool.d	2007-09-20 08:24:15.000000000 +0200
@@ -32,10 +32,10 @@
   }
 
   public void addBullet(float deg, float speed) {
-    BulletActor ba = (BulletActor) getInstance();
+    BulletActor ba = cast(BulletActor) getInstance();
     if (!ba)
       return;
-    P47Bullet rb = (P47Bullet) Bullet.now;
+    P47Bullet rb = cast(P47Bullet) Bullet.now;
     if (rb.isMorph) {
       BulletMLRunner *runner = BulletMLRunner_new_parser(rb.morphParser[rb.morphIdx]);
       BulletActorPool.registFunctions(runner);
@@ -51,12 +51,12 @@
   }
 
   public void addBullet(BulletMLState *state, float deg, float speed) {
-    BulletActor ba = (BulletActor) getInstance();
+    BulletActor ba = cast(BulletActor) getInstance();
     if (!ba)
       return;
     BulletMLRunner* runner = BulletMLRunner_new_state(state);
     registFunctions(runner);
-    P47Bullet rb = (P47Bullet) Bullet.now;
+    P47Bullet rb = cast(P47Bullet) Bullet.now;
     if (rb.isMorph)
       ba.set(runner, Bullet.now.pos.x, Bullet.now.pos.y, deg, speed, 
 	     Bullet.now.rank, 
@@ -72,7 +72,7 @@
 			       float x, float y, float deg, float speed,
 			       float rank, 
 			       float speedRank, int shape, int color, float size, float xReverse) {
-    BulletActor ba = (BulletActor) getInstance();
+    BulletActor ba = cast(BulletActor) getInstance();
     if (!ba)
       return null;
     ba.set(runner, x, y, deg, speed, rank, speedRank, shape, color, size, xReverse);
@@ -99,7 +99,7 @@
 			       float rank,
 			       float speedRank, int shape, int color, float size, float xReverse,
 			       BulletMLParser *morph[], int morphNum, int morphCnt) {
-    BulletActor ba = (BulletActor) getInstance();
+    BulletActor ba = cast(BulletActor) getInstance();
     if (!ba)
       return null;
     ba.set(runner, x, y, deg, speed, rank, 
@@ -119,14 +119,14 @@
   }
   
   public void killMe(Bullet bullet) {
-    assert(((BulletActor) actor[bullet.id]).bullet.id == bullet.id);
-    ((BulletActor) actor[bullet.id]).remove();
+    assert((cast(BulletActor) actor[bullet.id]).bullet.id == bullet.id);
+    (cast(BulletActor) actor[bullet.id]).remove();
   }
 
   public override void clear() {
     for (int i = 0; i < actor.length; i++) {
       if (actor[i].isExist)
-	((BulletActor) actor[i]).remove();
+	(cast(BulletActor) actor[i]).remove();
     }
   }
 
@@ -155,7 +155,7 @@
   double getAimDirectionWithXRev_(BulletMLRunner* r) {
     Vector b = Bullet.now.pos;
     Vector t = Bullet.target;
-    float xrev = ((P47Bullet) Bullet.now).xReverse;
+    float xrev = (cast(P47Bullet) Bullet.now).xReverse;
     return rtod(std.math.atan2(t.x - b.x, t.y - b.y) * xrev);
   }
 }
diff -Naur p47/src/abagames/p47/Enemy.d p47-gentoo/src/abagames/p47/Enemy.d
--- p47/src/abagames/p47/Enemy.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/Enemy.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.Enemy;
 
-private:
+//private:
 import std.math;
 import opengl;
 import bulletml;
@@ -78,7 +78,7 @@
   int velCnt;
   bool damaged;
   int bossTimer;
-  
+
   public static this() {
     rand = new Rand;
   }
@@ -88,7 +88,7 @@
   }
 
   public override void init(ActorInitializer ini) {
-    EnemyInitializer ei = (EnemyInitializer) ini;
+    EnemyInitializer ei = cast(EnemyInitializer) ini;
     field = ei.field;
     bullets = ei.bullets;
     shots = ei.shots;
@@ -107,13 +107,13 @@
   }
 
   public void set(Vector p, float d, EnemyType type, BulletMLParser *moveParser) {
-    pos.x = p.x; 
+    pos.x = p.x;
     pos.y = p.y;
     this.type = type;
     BulletMLRunner *moveRunner = BulletMLRunner_new_parser(moveParser);
     BulletActorPool.registFunctions(moveRunner);
     moveBullet = bullets.addBullet(moveRunner,
-				   pos.x, pos.y, d, 0, 0.5, 
+				   pos.x, pos.y, d, 0, 0.5,
 				   1, 0, 0, 1, 1);
     if (!moveBullet)
       return;
@@ -131,7 +131,7 @@
   }
 
   public void setBoss(Vector p, float d, EnemyType type) {
-    pos.x = p.x; 
+    pos.x = p.x;
     pos.y = p.y;
     this.type = type;
     moveBullet = null;
@@ -154,7 +154,7 @@
       int idx1 = rand.nextInt(movePointNum);
       int idx2 = rand.nextInt(movePointNum);
       if (idx1 == idx2) {
-	idx2++; 
+	idx2++;
 	if (idx2 >= movePointNum) idx2 = 0;
       }
       Vector mp = movePoint[idx1];
@@ -198,8 +198,8 @@
     if (br.morphCnt > 0)
       ba = bullets.addBullet
 	(br.parser, runner,
-	 bx, by, baseDeg, 0, br.rank, 
-	 br.speedRank, 
+	 bx, by, baseDeg, 0, br.rank,
+	 br.speedRank,
 	 br.shape, br.color, br.bulletSize,
 	 br.xReverse * xr,
 	 br.morphParser, br.morphNum, br.morphCnt);
@@ -207,7 +207,7 @@
       ba = bullets.addBullet
 	(br.parser, runner,
 	 bx, by, baseDeg, 0, br.rank,
-	 br.speedRank, 
+	 br.speedRank,
 	 br.shape, br.color, br.bulletSize,
 	 br.xReverse * xr);
     return ba;
@@ -234,7 +234,7 @@
   }
 
   private void addBonuses(Vector p, int sl) {
-    int bn = (float) sl * 3 / (((float) cnt / 30) + 1) * Bonus.rate + 0.9;
+    int bn = cast(int)(cast(float) sl * 3 / ((cast(float) cnt / 30) + 1) * Bonus.rate + 0.9);
     manager.addBonus(pos, p, bn);
   }
 
@@ -277,7 +277,7 @@
   private static int LOCK_DAMAGE = 7;
   private static const int ENEMY_TYPE_SCORE[] = [100, 500, 1000, 5000, 10000];
   private static const int ENEMY_WING_SCORE = 1000;
-  
+
   private void addDamage(int dmg) {
     shield -= dmg;
     if (shield <= 0) {
@@ -342,7 +342,7 @@
 
   // Check shots and rolls hit the enemy.
   private int checkHit(Vector p, float xofs, float yofs) {
-    if (fabs(p.x - pos.x) < type.collisionSize.x + xofs && 
+    if (fabs(p.x - pos.x) < type.collisionSize.x + xofs &&
 	fabs(p.y - pos.y) < type.collisionSize.y + yofs)
       return HIT;
     if (type.wingCollision) {
@@ -350,7 +350,7 @@
 	if (battery[i].shield <= 0)
 	  continue;
 	BatteryType bt = type.batteryType[i];
-	if (fabs(p.x - pos.x - bt.collisionPos.x) < bt.collisionSize.x + xofs && 
+	if (fabs(p.x - pos.x - bt.collisionPos.x) < bt.collisionSize.x + xofs &&
 	    fabs(p.y - pos.y - bt.collisionPos.y) < bt.collisionSize.y + yofs)
 	  return i;
       }
@@ -371,7 +371,7 @@
 	  continue;
 	BatteryType bt = type.batteryType[i];
 	float by = pos.y + bt.collisionPos.y;
-	if (fabs(p.x - pos.x - bt.collisionPos.x) < bt.collisionSize.x + xofs && 
+	if (fabs(p.x - pos.x - bt.collisionPos.x) < bt.collisionSize.x + xofs &&
 	    by < lock.lockMinY && by > p.y) {
 	  lock.lockMinY = by;
 	  lp = i;
@@ -389,7 +389,7 @@
     for (int i = 0; i < shots.actor.length; i++) {
       if (!shots.actor[i].isExist)
 	continue;
-      Vector sp = ((Shot) shots.actor[i]).pos;
+      Vector sp = (cast(Shot) shots.actor[i]).pos;
       ch = checkHit(sp, 0.7, 0);
       if (ch >= HIT) {
 	manager.addParticle(sp, rand.nextSignedFloat(0.3), 0, Shot.SPEED / 4);
@@ -407,7 +407,7 @@
       for (int i = 0; i < rolls.actor.length; i++) {
 	if (!rolls.actor[i].isExist)
 	  continue;
-	Roll rl = (Roll) rolls.actor[i];
+	Roll rl = cast(Roll) rolls.actor[i];
 	ch = checkHit(rl.pos[0], 1.0, 1.0);
 	if (ch >= HIT) {
 	  for (int i = 0; i < 4; i++)
@@ -420,9 +420,9 @@
 	      continue;
 	  }
 	  if (ch == HIT)
-	    addDamage(rd);
+	    addDamage(cast(int)rd);
 	  else
-	    addDamageBattery(ch, rd);
+	    addDamageBattery(ch, cast(int)rd);
 	}
       }
     } else if (type.type != EnemyType.SMALL) {
@@ -430,7 +430,7 @@
       for (int i = 0; i < locks.actor.length; i++) {
 	if (!locks.actor[i].isExist)
 	  continue;
-	Lock lk = (Lock) locks.actor[i];
+	Lock lk = cast(Lock) locks.actor[i];
 	if (lk.state == Lock.SEARCH || lk.state == Lock.SEARCHED) {
 	  ch = checkLocked(lk.pos[0], 2.5, lk);
 	  if (ch >= HIT) {
@@ -494,7 +494,7 @@
     float od = d - deg;
     if (od > std.math.PI)
       od -= std.math.PI * 2;
-    else if (od < -std.math.PI) 
+    else if (od < -std.math.PI)
       od += std.math.PI * 2;
     float aod = std.math.fabs(od);
     if (aod < BOSS_MOVE_DEG) {
@@ -595,7 +595,7 @@
 	if (z < 0)
 	  z -= APPEARANCE_Z / 60;
 	appCnt--;
-	mtr = 1.0 - (float)appCnt / APPEARANCE_CNT;
+	mtr = 1.0 - cast(float)appCnt / APPEARANCE_CNT;
       } else if (dstCnt > 0) {
 	addFragments(1, z, 0.05, rand.nextSignedFloat(std.math.PI));
 	manager.clearBullets();
@@ -609,7 +609,7 @@
 	  manager.setBossShieldMeter(0, 0, 0, 0, 0, 0);
 	  return;
 	}
-	mtr = (float)dstCnt / DESTROYED_CNT;
+	mtr = cast(float)dstCnt / DESTROYED_CNT;
       } else if (timeoutCnt > 0) {
 	z += DESTROYED_Z / 60;
 	timeoutCnt--;
@@ -641,16 +641,16 @@
     if (appCnt > 0) {
       // Appearance effect of the boss.
       P47Screen.setRetroZ(z);
-      ap = (float) appCnt / APPEARANCE_CNT;
+      ap = cast(float) appCnt / APPEARANCE_CNT;
       P47Screen.setRetroParam(1, type.retroSize * (1 + ap * 10));
       P47Screen.setRetroColor(type.r, type.g, type.b, (1 - ap));
     } else if (dstCnt > 0) {
       P47Screen.setRetroZ(z);
-      ap = (float) dstCnt / DESTROYED_CNT / 2 + 0.5;
+      ap = cast(float) dstCnt / DESTROYED_CNT / 2 + 0.5;
       P47Screen.setRetroColor(type.r, type.g, type.b, ap);
     } else if (timeoutCnt > 0) {
       P47Screen.setRetroZ(z);
-      ap = (float) timeoutCnt / TIMEOUT_CNT;
+      ap = cast(float) timeoutCnt / TIMEOUT_CNT;
       P47Screen.setRetroColor(type.r, type.g, type.b, ap);
     } else {
       P47Screen.setRetroParam(1, type.retroSize);
@@ -728,7 +728,7 @@
   Ship ship;
   P47GameManager manager;
 
-  public this(Field field, BulletActorPool bullets, ActorPool shots, 
+  public this(Field field, BulletActorPool bullets, ActorPool shots,
 	      ActorPool rolls, ActorPool locks, Ship ship, P47GameManager manager) {
     this.field = field;
     this.bullets = bullets;
diff -Naur p47/src/abagames/p47/EnemyType.d p47-gentoo/src/abagames/p47/EnemyType.d
--- p47/src/abagames/p47/EnemyType.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/EnemyType.d	2007-09-20 08:24:15.000000000 +0200
@@ -123,7 +123,7 @@
 
   // To avoid using the same morph pattern.
   private static bool usedMorphParser[BarrageManager.BARRAGE_MAX];
-  
+
   private void setBarrageType(Barrage br, int btn, int mode) {
     br.parser = barrageManager.parser
       [btn]
@@ -236,7 +236,7 @@
     }
   }
 
-  private static const float[][] enemySize = 
+  private static const float[][] enemySize =
     [
      [0.3, 0.3, 0.3, 0.1,  0.1,  1.0, 0.4, 0.6, 0.9],
      [0.4, 0.2, 0.4, 0.1,  0.15,  2.2, 0.2, 1.6, 1.0],
@@ -244,9 +244,9 @@
      [0.9, 0.3, 0.7, 0.2,  0.25,  5.0, 0.6, 3.0, 1.5],
      [1.2, 0.2, 0.9, 0.1,  0.3,  7.0, 0.8, 4.5, 1.5],
      ];
-  private enum {
-    SMALL, MIDDLE, LARGE, MIDDLEBOSS, LARGEBOSS,
-  }
+//  private enum {
+//    SMALL, MIDDLE, LARGE, MIDDLEBOSS, LARGEBOSS,
+  //}
 
   // Set the shepe of the BatteryType.
   private void setEnemyShapeAndWings(int size) {
@@ -370,7 +370,7 @@
   }
 
   // Set the barrage of the BatteryType.
-  private void setBattery(float rank, int n, int barrageType, int barrageIntense, 
+  private void setBattery(float rank, int n, int barrageType, int barrageIntense,
 			  int idx, int ptnIdx, float slow, int mode) {
     BatteryType bt = batteryType[idx];
     BatteryType bt2 = batteryType[idx + 1];
@@ -482,12 +482,12 @@
       shield = 40 + rand.nextInt(10);
       setBattery(sr, 1, BarrageManager.MIDDLESUB, NORMAL, 0, 0, 1, mode);
       fireInterval = 100 + rand.nextInt(60);
-      firePeriod = fireInterval / (1.8 + rand.nextFloat(0.7));
+      firePeriod = cast(int)(fireInterval / (1.8 + rand.nextFloat(0.7)));
     } else {
       shield = 30 + rand.nextInt(8);
       setBattery(sr, 1, BarrageManager.MIDDLESUB_LOCK, NORMAL, 0, 0, 1, mode);
       fireInterval = 72 + rand.nextInt(30);
-      firePeriod = fireInterval / (1.2 + rand.nextFloat(0.2));
+      firePeriod = cast(int)(fireInterval / (1.2 + rand.nextFloat(0.2)));
     }
     if (rank < 10)
       firePeriod /= (2 - rank * 0.1);
@@ -565,13 +565,13 @@
       setBattery(sr1, 1, BarrageManager.MIDDLESUB, NORMAL, 0, 0, 1, mode);
       setBattery(sr2, 1, BarrageManager.MIDDLESUB, NORMAL, 2, 0, 1, mode);
       fireInterval = 150 + rand.nextInt(60);
-      firePeriod = fireInterval / (1.3 + rand.nextFloat(0.8));
+      firePeriod = cast(int)(fireInterval / (1.3 + rand.nextFloat(0.8)));
     } else {
       shield = 45 + rand.nextInt(8);
       setBattery(sr1, 1, BarrageManager.MIDDLESUB_LOCK, NORMAL, 0, 0, 1, mode);
       setBattery(sr2, 1, BarrageManager.MIDDLESUB_LOCK, NORMAL, 2, 0, 1, mode);
       fireInterval = 100 + rand.nextInt(50);
-      firePeriod = fireInterval / (1.2 + rand.nextFloat(0.2));
+      firePeriod = cast(int)(fireInterval / (1.2 + rand.nextFloat(0.2)));
     }
     if (rank < 10)
       firePeriod /= (2 - rank * 0.1);
@@ -609,7 +609,7 @@
     }
     shield = 300 + rand.nextInt(50);
     fireInterval = 200 + rand.nextInt(40);
-    firePeriod = fireInterval / (1.2 + rand.nextFloat(0.4));
+    firePeriod = cast(int)(fireInterval / (1.2 + rand.nextFloat(0.4)));
     if (rank < 10)
       firePeriod /= (2 - rank * 0.1);
   }
@@ -650,7 +650,7 @@
     }
     shield = 400 + rand.nextInt(50);
     fireInterval = 220 + rand.nextInt(60);
-    firePeriod = fireInterval / (1.2 + rand.nextFloat(0.3));
+    firePeriod = cast(int)(fireInterval / (1.2 + rand.nextFloat(0.3)));
     if (rank < 10)
       firePeriod /= (2 - rank * 0.1);
   }
diff -Naur p47/src/abagames/p47/Field.d p47-gentoo/src/abagames/p47/Field.d
--- p47/src/abagames/p47/Field.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/Field.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.Field;
 
-private:
+//private:
 import std.math;
 import opengl;
 import abagames.util.Vector;
@@ -97,7 +97,7 @@
     float d = -RING_NUM * RING_ANGLE_INT / 2 + roll;
     for (int i = 0; i < RING_NUM; i++) {
       for (int j = 1; j < 8; j++) {
-	float sc = (float) j / 16 + 0.5;
+	float sc = cast(float) j / 16 + 0.5;
 	glPushMatrix();
 	glTranslatef(0, 0, z);
 	glRotatef(d, 1, 0, 0);
@@ -118,7 +118,7 @@
   }
 
   public bool checkHit(Vector p, float space) {
-    if (p.x < -size.x + space || p.x > size.x - space || 
+    if (p.x < -size.x + space || p.x > size.x - space ||
 	p.y < -size.y + space || p.y > size.y - space)
       return true;
     return false;
@@ -126,7 +126,7 @@
 
   private static const int RING_POS_NUM = 16;
   private static Vector ringPos[RING_POS_NUM];
-  private static const float RING_DEG = std.math.PI / 3 / ((float) (RING_POS_NUM / 2) + 0.5);
+  private static const float RING_DEG = std.math.PI / 3 / (cast(float) (RING_POS_NUM / 2) + 0.5);
   private static const float RING_RADIUS = 10;
   private static const float RING_SIZE = 0.5;
 
@@ -134,10 +134,10 @@
     glBegin(GL_LINE_STRIP);
     for (int i = 0; i <= RING_POS_NUM / 2 - 2; i++) {
       glVertex3f(ringPos[i].x, RING_SIZE, ringPos[i].y);
-    } 
+    }
     for (int i = RING_POS_NUM / 2 - 2; i >= 0; i--) {
       glVertex3f(ringPos[i].x, -RING_SIZE, ringPos[i].y);
-    } 
+    }
     glVertex3f(ringPos[0].x, RING_SIZE, ringPos[0].y);
     glEnd();
     glBegin(GL_LINE_STRIP);
@@ -150,16 +150,16 @@
     glBegin(GL_LINE_STRIP);
     for (int i = RING_POS_NUM / 2 + 1;  i <= RING_POS_NUM - 1; i++) {
       glVertex3f(ringPos[i].x, RING_SIZE, ringPos[i].y);
-    } 
+    }
     for (int i = RING_POS_NUM - 1; i >= RING_POS_NUM / 2 + 1; i--) {
       glVertex3f(ringPos[i].x, -RING_SIZE, ringPos[i].y);
-    } 
+    }
     glVertex3f(ringPos[RING_POS_NUM / 2 + 1].x, RING_SIZE, ringPos[RING_POS_NUM / 2 + 1].y);
     glEnd();
   }
 
   public static void createDisplayLists() {
-    float d = -RING_DEG * ((float) (RING_POS_NUM / 2) - 0.5);
+    float d = -RING_DEG * (cast(float) (RING_POS_NUM / 2) - 0.5);
     for (int i = 0; i < RING_POS_NUM; i++, d += RING_DEG) {
       ringPos[i] = new Vector;
       ringPos[i].x = sin(d) * RING_RADIUS;
diff -Naur p47/src/abagames/p47/Fragment.d p47-gentoo/src/abagames/p47/Fragment.d
--- p47/src/abagames/p47/Fragment.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/Fragment.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.Fragment;
 
-private:
+//private:
 import std.math;
 import opengl;
 import abagames.util.Vector;
@@ -43,7 +43,7 @@
   }
 
   public override void init(ActorInitializer ini) {
-    FragmentInitializer fi = (FragmentInitializer) ini;
+    FragmentInitializer fi = cast(FragmentInitializer) ini;
     for (int i = 0; i < POINT_NUM; i++) {
       pos[i] = new Vector;
       vel[i] = new Vector;
diff -Naur p47/src/abagames/p47/LetterRender.d p47-gentoo/src/abagames/p47/LetterRender.d
--- p47/src/abagames/p47/LetterRender.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/LetterRender.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.LetterRender;
 
-private:
+//private:
 import opengl;
 import abagames.util.sdl.Screen3D;
 import abagames.p47.P47Screen;
@@ -23,7 +23,7 @@
     WHITE, RED
   }
 
-  private static void changeColor(int c) {
+  public static void changeColor(int c) {
     colorIdx = c * LETTER_NUM;
   }
 
@@ -177,22 +177,22 @@
     float x, y, length, size, t;
     int deg;
     for (int i = 0;; i++) {
-      deg = (int) spData[idx][i][4];
+      deg = cast(int) spData[idx][i][4];
       if (deg > 99990) break;
-      x = -spData[idx][i][0]; 
+      x = -spData[idx][i][0];
       y = -spData[idx][i][1];
-      size = spData[idx][i][2]; 
+      size = spData[idx][i][2];
       length = spData[idx][i][3];
-      size *= 0.66f; 
+      size *= 0.66f;
       length *= 0.6f;
-      x = -x; 
+      x = -x;
       y = y;
       deg %= 180;
-      if (deg <= 45 || deg > 135) 
+      if (deg <= 45 || deg > 135)
 	drawBox(x, y, size, length, r, g, b);
-      else 
+      else
 	drawBox(x, y, length, size, r, g, b);
-    }    
+    }
   }
 
   private static const int LETTER_NUM = 42;
@@ -215,7 +215,7 @@
     glDeleteLists(displayListIdx, LETTER_NUM * 2);
   }
 
-  private static float[5][16][] spData = 
+  private static float[5][16][] spData =
     [[
      [0, 1.15f, 0.65f, 0.3f, 0],
      [-0.6f, 0.55f, 0.65f, 0.3f, 90], [0.6f, 0.55f, 0.65f, 0.3f, 90],
diff -Naur p47/src/abagames/p47/Lock.d p47-gentoo/src/abagames/p47/Lock.d
--- p47/src/abagames/p47/Lock.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/Lock.d	2007-09-20 08:24:15.000000000 +0200
@@ -52,7 +52,7 @@
   }
 
   public override void init(ActorInitializer ini) {
-    LockInitializer li = (LockInitializer) ini;
+    LockInitializer li = cast(LockInitializer) ini;
     ship = li.ship;
     field = li.field;
     manager = li.manager;
diff -Naur p47/src/abagames/p47/LuminousActorPool.d p47-gentoo/src/abagames/p47/LuminousActorPool.d
--- p47/src/abagames/p47/LuminousActorPool.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/LuminousActorPool.d	2007-09-20 08:24:15.000000000 +0200
@@ -22,7 +22,7 @@
   public void drawLuminous() {
     for (int i = 0; i < actor.length; i++) {
       if (actor[i].isExist)
-	((LuminousActor) actor[i]).drawLuminous();
+	(cast(LuminousActor) actor[i]).drawLuminous();
     }
   }
 }
diff -Naur p47/src/abagames/p47/LuminousScreen.d p47-gentoo/src/abagames/p47/LuminousScreen.d
--- p47/src/abagames/p47/LuminousScreen.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/LuminousScreen.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.LuminousScreen;
 
-private:
+//private:
 import std.math;
 import std.string;
 import opengl;
@@ -19,7 +19,7 @@
   GLuint luminousTexture;
   const int LUMINOUS_TEXTURE_WIDTH_MAX = 64;
   const int LUMINOUS_TEXTURE_HEIGHT_MAX = 64;
-  GLuint td[LUMINOUS_TEXTURE_WIDTH_MAX * LUMINOUS_TEXTURE_HEIGHT_MAX * 4 * uint.size];
+  GLuint td[LUMINOUS_TEXTURE_WIDTH_MAX * LUMINOUS_TEXTURE_HEIGHT_MAX * 4 * uint.sizeof];
   int luminousTextureWidth = 64, luminousTextureHeight = 64;
   int screenWidth, screenHeight;
   float luminous;
@@ -27,7 +27,7 @@
   private void makeLuminousTexture() {
     uint *data = td;
     int i;
-    memset(data, 0, luminousTextureWidth * luminousTextureHeight * 4 * uint.size);
+   // cast(data, 0, luminousTextureWidth * luminousTextureHeight * 4 * uint.sizeof);
     glGenTextures(1, &luminousTexture);
     glBindTexture(GL_TEXTURE_2D, luminousTexture);
     glTexImage2D(GL_TEXTURE_2D, 0, 4, luminousTextureWidth, luminousTextureHeight, 0,
@@ -57,7 +57,7 @@
 
   public void endRenderToTexture() {
     glBindTexture(GL_TEXTURE_2D, luminousTexture);
-    glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 
+    glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
 		     0, 0, luminousTextureWidth, luminousTextureHeight, 0);
     glViewport(0, 0, screenWidth, screenHeight);
   }
diff -Naur p47/src/abagames/p47/P47Boot.d p47-gentoo/src/abagames/p47/P47Boot.d
--- p47/src/abagames/p47/P47Boot.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/P47Boot.d	2007-09-20 08:24:15.000000000 +0200
@@ -6,7 +6,7 @@
 module abagames.p47.P47Boot;
 
 private:
-import std.string;
+//import std.string;
 import std.c.stdlib;
 import abagames.util.Logger;
 import abagames.util.sdl.Pad;
@@ -42,7 +42,7 @@
 	throw new Exception("Invalid options");
       }
       i++;
-      float b = (float) atoi(args[i]) / 100;
+      float b = cast(float) atoi(args[i]) / 100;
       if (b < 0 || b > 1) {
 	usage(args[0]);
 	throw new Exception("Invalid options");
@@ -55,7 +55,7 @@
 	throw new Exception("Invalid options");
       }
       i++;
-      float l = (float) atoi(args[i]) / 100;
+      float l = cast(float) atoi(args[i]) / 100;
       if (l < 0 || l > 1) {
 	usage(args[0]);
 	throw new Exception("Invalid options");
diff -Naur p47/src/abagames/p47/P47GameManager.d p47-gentoo/src/abagames/p47/P47GameManager.d
--- p47/src/abagames/p47/P47GameManager.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/P47GameManager.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,10 +5,33 @@
  */
 module abagames.p47.P47GameManager;
 
-private:
+//private:
 import std.math;
 import opengl;
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 import bulletml;
 import abagames.util.Rand;
 import abagames.util.Vector;
@@ -88,9 +111,9 @@
 
   // Initialize actor pools, load BGMs/SEs and textures.
   public override void init() {
-    pad = (Pad) input;
-    prefManager = (P47PrefManager) abstPrefManager;
-    screen = (P47Screen) abstScreen;
+    pad = cast(Pad) input;
+    prefManager = cast(P47PrefManager) abstPrefManager;
+    screen = cast(P47Screen) abstScreen;
     rand = new Rand;
     Field.createDisplayLists();
     field = new Field;
@@ -177,22 +200,22 @@
   }
 
   public void addParticle(Vector pos, float deg, float ofs, float speed) {
-    Particle pt = (Particle) particles.getInstanceForced();
+    Particle pt = cast(Particle) particles.getInstanceForced();
     assert(pt);
     pt.set(pos, deg, ofs, speed);
   }
 
-  public void addFragments(int n, float x1, float y1, float x2, float y2, float z, 
+  public void addFragments(int n, float x1, float y1, float x2, float y2, float z,
 			   float speed, float deg) {
     for (int i = 0; i < n; i++) {
-      Fragment ft = (Fragment) fragments.getInstanceForced();
+      Fragment ft = cast(Fragment) fragments.getInstanceForced();
       assert(ft);
       ft.set(x1, y1, x2, y2, z, speed, deg);
     }
   }
 
   public void addEnemy(Vector pos, float d, EnemyType type, BulletMLParser *moveParser) {
-    Enemy en = (Enemy) enemies.getInstance();
+    Enemy en = cast(Enemy) enemies.getInstance();
     if (!en)
       return;
     en.set(pos, d, type, moveParser);
@@ -202,33 +225,33 @@
     for (int i = 0; i < bullets.actor.length; i++) {
       if (!bullets.actor[i].isExist)
 	continue;
-      ((BulletActor) bullets.actor[i]).toRetro();
+      (cast(BulletActor) bullets.actor[i]).toRetro();
     }
   }
 
   public void addBoss(Vector pos, float d, EnemyType type) {
-    Enemy en = (Enemy) enemies.getInstance();
+    Enemy en = cast(Enemy) enemies.getInstance();
     if (!en)
       return;
     en.setBoss(pos, d, type);
   }
 
   public void addShot(Vector pos, float deg) {
-    Shot shot = (Shot) shots.getInstance();
+    Shot shot = cast(Shot) shots.getInstance();
     if (!shot)
       return;
     shot.set(pos, deg);
   }
 
   public void addRoll() {
-    Roll roll = (Roll) rolls.getInstance();
+    Roll roll = cast(Roll) rolls.getInstance();
     if (!roll)
       return;
     roll.set();
   }
 
   public void addLock() {
-    Lock lock = (Lock) locks.getInstance();
+    Lock lock = cast(Lock) locks.getInstance();
     if (!lock)
       return;
     lock.set();
@@ -238,7 +261,7 @@
     for (int i = 0; i < rolls.actor.length; i++) {
       if (!rolls.actor[i].isExist)
 	continue;
-      ((Roll) rolls.actor[i]).released = true;
+      (cast(Roll) rolls.actor[i]).released = true;
     }
   }
 
@@ -246,14 +269,14 @@
     for (int i = 0; i < locks.actor.length; i++) {
       if (!locks.actor[i].isExist)
 	continue;
-      ((Lock) locks.actor[i]).released = true;
+      (cast(Lock) locks.actor[i]).released = true;
     }
   }
 
 
   public void addBonus(Vector pos, Vector ofs, int num) {
     for (int i = 0; i < num; i++) {
-      Bonus bonus = (Bonus) bonuses.getInstance();
+      Bonus bonus = cast(Bonus) bonuses.getInstance();
       if (!bonus)
 	return;
       bonus.set(pos, ofs);
@@ -262,11 +285,11 @@
 
   public void setBossShieldMeter(int bs, int s1, int s2, int s3, int s4, float r) {
     r *= 0.7;
-    bossShield = bs * r;
-    bossWingShield[0] = s1 * r ;
-    bossWingShield[1] = s2 * r;
-    bossWingShield[2] = s3 * r;
-    bossWingShield[3] = s4 * r;
+    bossShield = cast(int)(bs * r);
+    bossWingShield[0] = cast(int)(s1 * r);
+    bossWingShield[1] = cast(int)(s2 * r);
+    bossWingShield[2] = cast(int)(s3 * r);
+    bossWingShield[3] = cast(int)(s4 * r);
   }
 
   // Difficulty.
@@ -341,7 +364,7 @@
     rolls.clear();
     locks.clear();
     setScreenShake(0, 0);
-    mainLoop.interval = interval = mainLoop.INTERVAL_BASE;
+    mainLoop.interval = cast(int)(interval = mainLoop.INTERVAL_BASE);
     cnt = 0;
     if (score > prefManager.hiScore[mode][difficulty][parsecSlot])
       prefManager.hiScore[mode][difficulty][parsecSlot] = score;
@@ -396,10 +419,10 @@
 	if (sm > 1.75)
 	  sm = 1.75;
 	interval += (sm * mainLoop.INTERVAL_BASE - interval) * 0.1;
-	mainLoop.interval = interval;
+	mainLoop.interval = cast(int)(interval);
       } else {
 	interval += (mainLoop.INTERVAL_BASE - interval) * 0.08;
-	mainLoop.interval = interval;
+	mainLoop.interval = cast(int)(interval);
       }
     }
   }
@@ -452,7 +475,7 @@
 	startTitle();
     } else if (cnt > 500) {
 	startTitle();
-    } 
+    }
     field.move();
     enemies.move();
     bullets.move();
@@ -578,7 +601,7 @@
     LetterRender.drawNum(Bonus.bonusScore, 24, 20, 12, LetterRender.TO_UP);
   }
 
-  private void drawLeft() {
+  public void drawLeft() {
     if (left < 0)
       return;
     LetterRender.drawString("LEFT", 520, 260, 25, LetterRender.TO_DOWN);
diff -Naur p47/src/abagames/p47/P47PrefManager.d p47-gentoo/src/abagames/p47/P47PrefManager.d
--- p47/src/abagames/p47/P47PrefManager.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/P47PrefManager.d	2007-09-20 08:24:15.000000000 +0200
@@ -53,6 +53,10 @@
     auto File fd = new File;
     try {
       int ver;
+//      if (exists(PREF_FILE) == 0){
+  //      init();
+    //    save();
+      //}
       fd.open(PREF_FILE);
       fd.read(ver);
       if (ver == PREV_VERSION_NUM) {
diff -Naur p47/src/abagames/p47/P47Screen.d p47-gentoo/src/abagames/p47/P47Screen.d
--- p47/src/abagames/p47/P47Screen.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/P47Screen.d	2007-09-20 08:24:15.000000000 +0200
@@ -5,7 +5,7 @@
  */
 module abagames.p47.P47Screen;
 
-private:
+//private:
 import std.math;
 import opengl;
 import abagames.util.Rand;
@@ -33,7 +33,7 @@
     glDisable(GL_CULL_FACE);
     glDisable(GL_DEPTH_TEST);
     glDisable(GL_TEXTURE_2D);
-    glDisable(GL_COLOR_MATERIAL);    
+    glDisable(GL_COLOR_MATERIAL);
     rand = new Rand;
     if (luminous > 0) {
       luminousScreen = new LuminousScreen;
@@ -128,7 +128,7 @@
       float ly = std.math.fabs(y2 - y1);
       glBegin(GL_QUADS);
       if (lx < ly) {
-	int n = ly / ds;
+	int n = cast(int)(ly / ds);
 	if (n > 0) {
 	  float xo = (x2 - x1) / n, xos  = 0;
 	  float yo;
@@ -152,7 +152,7 @@
 	  }
 	}
       } else {
-	int n = lx / ds;
+	int n = cast(int)(lx / ds);
 	if (n > 0) {
 	  float yo = (y2 - y1) / n, yos = 0;
 	  float xo;
diff -Naur p47/src/abagames/p47/Roll.d p47-gentoo/src/abagames/p47/Roll.d
--- p47/src/abagames/p47/Roll.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/Roll.d	2007-09-20 08:24:15.000000000 +0200
@@ -40,7 +40,7 @@
   }
 
   public override void init(ActorInitializer ini) {
-    RollInitializer ri = (RollInitializer) ini;
+    RollInitializer ri = cast(RollInitializer) ini;
     ship = ri.ship;
     field = ri.field;
     manager = ri.manager;
diff -Naur p47/src/abagames/p47/Shot.d p47-gentoo/src/abagames/p47/Shot.d
--- p47/src/abagames/p47/Shot.d	2004-01-01 20:26:42.000000000 +0100
+++ p47-gentoo/src/abagames/p47/Shot.d	2007-09-20 08:24:15.000000000 +0200
@@ -35,7 +35,7 @@
   }
 
   public override void init(ActorInitializer ini) {
-    ShotInitializer si = (ShotInitializer) ini;
+    ShotInitializer si = cast(ShotInitializer) ini;
     field = si.field;
     pos = new Vector;
     vel = new Vector;
diff -Naur p47/src/abagames/util/Logger.d p47-gentoo/src/abagames/util/Logger.d
--- p47/src/abagames/util/Logger.d	2004-01-01 20:26:44.000000000 +0100
+++ p47-gentoo/src/abagames/util/Logger.d	2007-09-20 08:24:15.000000000 +0200
@@ -52,26 +52,26 @@
 public class Logger {
 
   public static void info(char[] msg) {
-    stderr.writeLine("Info: " ~ msg);
+//    stderr.writeLine("Info: " ~ msg);
   }
 
   public static void info(int n) {
-    if (n >= 0)
-      stderr.writeLine("Info: " ~ std.string.toString(n));
-    else
-      stderr.writeLine("Info: -" ~ std.string.toString(-n));
+  //  if (n >= 0)
+  //    stderr.writeLine("Info: " ~ std.string.toString(n));
+//    else
+  //    stderr.writeLine("Info: -" ~ std.string.toString(-n));
   }
 
   public static void error(char[] msg) {
-    stderr.writeLine("Error: " ~ msg);
+   // stderr.writeLine("Error: " ~ msg);
   }
 
   public static void error(Exception e) {
-    stderr.writeLine("Error: " ~ e.toString());
+  //  stderr.writeLine("Error: " ~ e.toString());
   }
 
   public static void error(Error e) {
-    stderr.writeLine("Error: " ~ e.toString());
+    //stderr.writeLine("Error: " ~ e.toString());
     if (e.next)
       error(e.next);
   }
diff -Naur p47/src/abagames/util/sdl/Input.d p47-gentoo/src/abagames/util/sdl/Input.d
--- p47/src/abagames/util/sdl/Input.d	2004-01-01 20:26:44.000000000 +0100
+++ p47-gentoo/src/abagames/util/sdl/Input.d	2007-09-20 08:24:15.000000000 +0200
@@ -7,6 +7,29 @@
 
 private:
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 
 /**
  * Input device interface.
diff -Naur p47/src/abagames/util/sdl/MainLoop.d p47-gentoo/src/abagames/util/sdl/MainLoop.d
--- p47/src/abagames/util/sdl/MainLoop.d	2004-01-01 20:26:44.000000000 +0100
+++ p47-gentoo/src/abagames/util/sdl/MainLoop.d	2007-09-20 08:24:15.000000000 +0200
@@ -8,6 +8,29 @@
 private:
 import std.string;
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 import abagames.util.Logger;
 import abagames.util.Rand;
 import abagames.util.PrefManager;
@@ -88,7 +111,7 @@
       if (event.type == SDL_QUIT)
 	breakLoop();
       nowTick = SDL_GetTicks();
-      frame = (int) (nowTick-prvTickCount) / interval;
+      frame = cast(int) (nowTick-prvTickCount) / interval;
       if (frame <= 0) {
 	frame = 1;
 	SDL_Delay(prvTickCount+interval-nowTick);
diff -Naur p47/src/abagames/util/sdl/Pad.d p47-gentoo/src/abagames/util/sdl/Pad.d
--- p47/src/abagames/util/sdl/Pad.d	2004-01-01 20:26:44.000000000 +0100
+++ p47-gentoo/src/abagames/util/sdl/Pad.d	2007-09-20 08:24:15.000000000 +0200
@@ -8,6 +8,29 @@
 private:
 import std.string;
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 import abagames.util.sdl.Input;
 import abagames.util.sdl.SDLInitFailedException;
 
diff -Naur p47/src/abagames/util/sdl/Screen3D.d p47-gentoo/src/abagames/util/sdl/Screen3D.d
--- p47/src/abagames/util/sdl/Screen3D.d	2004-01-01 20:26:44.000000000 +0100
+++ p47-gentoo/src/abagames/util/sdl/Screen3D.d	2007-09-20 08:24:15.000000000 +0200
@@ -8,6 +8,29 @@
 private:
 import std.string;
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 import opengl;
 import abagames.util.Logger;
 import abagames.util.sdl.Screen;
@@ -47,7 +70,7 @@
       videoFlags = SDL_OPENGL | SDL_RESIZABLE;
     } else {
       videoFlags = SDL_OPENGL | SDL_FULLSCREEN;
-    } 
+    }
     if (SDL_SetVideoMode(width, height, 0, videoFlags) == null) {
       throw new SDLInitFailedException
 	("Unable to create SDL screen: " ~ std.string.toString(SDL_GetError()));
@@ -67,8 +90,8 @@
     //gluPerspective(45.0f, (GLfloat)width/(GLfloat)height, nearPlane, farPlane);
     glFrustum(-nearPlane,
 	      nearPlane,
-	      -nearPlane * (GLfloat)height / (GLfloat)width,
-	      nearPlane * (GLfloat)height / (GLfloat)width,
+	      -nearPlane * cast(GLfloat)height / cast(GLfloat)width,
+	      nearPlane * cast(GLfloat)height / cast(GLfloat)width,
 	      0.1f, farPlane);
     glMatrixMode(GL_MODELVIEW);
   }
diff -Naur p47/src/abagames/util/sdl/Sound.d p47-gentoo/src/abagames/util/sdl/Sound.d
--- p47/src/abagames/util/sdl/Sound.d	2004-01-01 20:26:44.000000000 +0100
+++ p47-gentoo/src/abagames/util/sdl/Sound.d	2007-09-20 08:24:15.000000000 +0200
@@ -8,6 +8,29 @@
 private:
 import std.string;
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 import SDL_mixer;
 import abagames.util.sdl.SDLInitFailedException;
 
diff -Naur p47/src/abagames/util/sdl/Texture.d p47-gentoo/src/abagames/util/sdl/Texture.d
--- p47/src/abagames/util/sdl/Texture.d	2004-01-01 20:26:44.000000000 +0100
+++ p47-gentoo/src/abagames/util/sdl/Texture.d	2007-09-20 08:24:15.000000000 +0200
@@ -9,6 +9,29 @@
 import std.string;
 import opengl;
 import SDL;
+import SDL_active;   
+import SDL_joystick;  
+import SDL_mutex;   
+import SDL_timer;
+import SDL_audio;      
+import SDL_endian;  
+import SDL_keyboard;  
+import SDL_quit;
+import SDL_types;
+import SDL_byteorder;  
+import SDL_error;
+import SDL_Keysym;    
+import SDL_rwops;   
+import SDL_version;
+import SDL_cdrom;   
+import SDL_events;  
+import SDL_syswm;  
+import SDL_Version;
+import SDL_copying;  
+import SDL_getenv;
+import SDL_mouse;   
+import SDL_thread;  
+import SDL_video;
 import abagames.util.sdl.SDLInitFailedException;
 
 /**
diff -Naur p47/src/dirent_d.c p47-gentoo/src/dirent_d.c
--- p47/src/dirent_d.c	2003-11-29 02:26:30.000000000 +0100
+++ p47-gentoo/src/dirent_d.c	2007-09-20 08:24:15.000000000 +0200
@@ -1,50 +1,4 @@
-#ifdef WINDOWS
 
-#include <windows.h>
-
-#include <stdio.h>
-#include <malloc.h>
-
-typedef struct {
-	HANDLE h;
-	char* prev;
-} DIR;
-
-DIR* opendir(char* dir) {
-	WIN32_FIND_DATA fd;
-	HANDLE h;
-	DIR* d;
-	char buf[MAX_PATH];
-
-	sprintf(buf, "%s/*", dir);
-	h = FindFirstFileA(buf, &fd);
-	d = (DIR*)malloc(sizeof(DIR));
-	d->h = h;
-	d->prev = 0;
-	return d;
-}
-
-char* readdir_filename(DIR* d) {
-	WIN32_FIND_DATA fd;
-	BOOL ret = FindNextFileA(d->h, &fd);
-	if (ret) {
-		if (d->prev != 0) free(d->prev);
-		d->prev = malloc(sizeof(char) * strlen(fd.cFileName));
-		strcpy(d->prev, fd.cFileName);
-		return d->prev;
-	}
-	else {
-		return NULL;
-	}
-}
-
-int closedir(DIR* d) {
-	FindClose(d->h);
-	free(d->prev);
-	free(d);
-}
-
-#else // ! WINDOWS
 
 #include "dirent.h"
 #include "unistd.h"
@@ -55,5 +9,5 @@
 	else return ent->d_name;
 }
 
-#endif // WINDOWS
+
 
diff -Naur p47/src/mt.d p47-gentoo/src/mt.d
--- p47/src/mt.d	2003-11-29 02:26:30.000000000 +0100
+++ p47-gentoo/src/mt.d	2007-09-20 08:24:15.000000000 +0200
@@ -162,7 +162,7 @@
     y ^= (y << 15) & 0xefc60000UL;
     y ^= (y >> 18);
 
-    return (long)(y>>1);
+    return cast(long)(y>>1);
 }
 
 /* generates a random number on [0,1]-real-interval */
@@ -179,7 +179,7 @@
     y ^= (y << 15) & 0xefc60000UL;
     y ^= (y >> 18);
 
-    return (double)y * (1.0/4294967295.0); 
+    return cast(double)y * (1.0/4294967295.0); 
     /* divided by 2^32-1 */ 
 }
 
@@ -197,7 +197,7 @@
     y ^= (y << 15) & 0xefc60000UL;
     y ^= (y >> 18);
 
-    return (double)y * (1.0/4294967296.0); 
+    return cast(double)y * (1.0/4294967296.0); 
     /* divided by 2^32 */
 }
 
@@ -215,7 +215,7 @@
     y ^= (y << 15) & 0xefc60000UL;
     y ^= (y >> 18);
 
-    return ((double)y + 0.5) * (1.0/4294967296.0); 
+    return (cast(double)y + 0.5) * (1.0/4294967296.0); 
     /* divided by 2^32 */
 }
 
